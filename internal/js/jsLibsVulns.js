var npm = {
    "@angular/core":[
      {"id":"SNYK-JS-ANGULARCORE-1070902","severity":"low","semver":{"vulnerable":["<11.0.5",">=11.1.0-next.0 <11.1.0-next.3"]}}
    ],
    "angular":[
      {"id":"SNYK-JS-ANGULAR-572020","severity":"high","semver":{"vulnerable":["<1.8.0"]}},
      {"id":"SNYK-JS-ANGULAR-570058","severity":"medium","semver":{"vulnerable":["<1.8.0"]}},
      {"id":"SNYK-JS-ANGULAR-534884","severity":"high","semver":{"vulnerable":[">=1.4.0-beta.6 <1.7.9"]}},
      {"id":"SNYK-JS-ANGULAR-471885","severity":"medium","semver":{"vulnerable":["<1.6.3"]}},
      {"id":"SNYK-JS-ANGULAR-471882","severity":"medium","semver":{"vulnerable":["<1.6.5"]}},
      {"id":"SNYK-JS-ANGULAR-471879","severity":"medium","semver":{"vulnerable":["<1.6.0-rc.0"]}},
      {"id":"npm:angular:20180202","severity":"medium","semver":{"vulnerable":["<1.6.9"]}},
      {"id":"npm:angular:20171018","severity":"medium","semver":{"vulnerable":["<1.6.7"]}},
      {"id":"npm:angular:20160527","severity":"medium","semver":{"vulnerable":[">=1.0.0 <1.2.30"]}},
      {"id":"npm:angular:20160122","severity":"medium","semver":{"vulnerable":[">=1.3.0 <1.5.0-rc.2"]}},
      {"id":"npm:angular:20140608","severity":"low","semver":{"vulnerable":["<1.3.0"]}},
      {"id":"npm:angular:20131113","severity":"high","semver":{"vulnerable":["<1.2.2"]}},
      {"id":"npm:angular:20140908","severity":"medium","semver":{"vulnerable":["<1.3.0-rc.4"]}},
      {"id":"npm:angular:20161101","severity":"medium","semver":{"vulnerable":[">=1.5.0 <1.5.9"]}},
      {"id":"npm:angular:20150909","severity":"high","semver":{"vulnerable":["<1.5.0-beta.2"]}},
      {"id":"npm:angular:20151205","severity":"medium","semver":{"vulnerable":["<1.5.0-rc.0"]}},
      {"id":"npm:angular:20151130","severity":"medium","semver":{"vulnerable":["<1.4.10"]}},
      {"id":"npm:angular:20130622","severity":"medium","semver":{"vulnerable":[">=1.0.0 <1.2.0"]}},
      {"id":"npm:angular:20150807-1","severity":"medium","semver":{"vulnerable":[">=1.3.1 <1.5.0-beta.0"]}},
      {"id":"npm:angular:20150807","severity":"high","semver":{"vulnerable":[">=1.0.0 <1.5.0-beta.0"]}},
      {"id":"npm:angular:20150315","severity":"medium","semver":{"vulnerable":["<1.6.1"]}},
      {"id":"npm:angular:20150310","severity":"high","semver":{"vulnerable":["<1.4.0-beta.6"]}},
      {"id":"npm:angular:20141104","severity":"medium","semver":{"vulnerable":["<1.3.2"]}},
      {"id":"npm:angular:20130621","severity":"medium","semver":{"vulnerable":["<1.2.0"]}},
      {"id":"npm:angular:20140909","severity":"high","semver":{"vulnerable":[">=1.2.19 <1.2.24"]}},
      {"id":"npm:angular:20130625","severity":"high","semver":{"vulnerable":["<1.1.5"]}}
    ],
    "backbone":[
      {"id":"npm:backbone:20160523","severity":"medium","semver":{"vulnerable":["<0.1.2"]}},
      {"id":"npm:backbone:20110701","severity":"medium","semver":{"vulnerable":["<0.5.0"]}}
    ],
    "bootstrap":[
      {"id":"SNYK-JS-BOOTSTRAP-173700","severity":"medium","semver":{"vulnerable":["<3.4.1",">=4.0.0 <4.3.1"]}},
      {"id":"SNYK-JS-BOOTSTRAP-73560","severity":"medium","semver":{"vulnerable":[">=4.0.0 <4.1.2"]}},
      {"id":"SNYK-JS-BOOTSTRAP-72890","severity":"medium","semver":{"vulnerable":["<3.4.0"]}},
      {"id":"SNYK-JS-BOOTSTRAP-72889","severity":"medium","semver":{"vulnerable":["<3.4.0"]}},
      {"id":"npm:bootstrap:20180529","severity":"medium","semver":{"vulnerable":["<3.4.0",">=4.0.0 <4.1.2"]}},
      {"id":"npm:bootstrap:20160627","severity":"medium","semver":{"vulnerable":["<3.4.0",">=4.0.0-alpha <4.0.0-beta.2"]}},
      {"id":"npm:bootstrap:20120510","severity":"medium","semver":{"vulnerable":["<2.1.0"]}}
    ],
    "dojo":[
      {"id":"SNYK-JS-DOJO-559224","severity":"medium","semver":{"vulnerable":["<1.11.10",">=1.12.0 <1.12.8",">=1.13.0 <1.13.7",">=1.14.0 <1.14.6",">=1.15.0 <1.15.3",">=1.16.0 <1.16.2"]}},
      {"id":"SNYK-JS-DOJO-174934","severity":"medium","semver":{"vulnerable":[">=1.0.0 <1.0.3",">=1.1.0 <1.1.2",">=1.2.0 <1.2.4",">=1.3.0 <1.3.3",">=1.4.0 <1.4.2"]}},
      {"id":"SNYK-JS-DOJO-174933","severity":"medium","semver":{"vulnerable":["<1.2.0"]}},
      {"id":"SNYK-JS-DOJO-72305","severity":"medium","semver":{"vulnerable":[">=1.14.0-pre <1.14.0",">=1.13.0 <1.13.1",">=1.12.1 <1.12.4",">=1.11.0-rc1 <1.11.6","<1.10.10"]}},
      {"id":"npm:dojo:20180818","severity":"medium","semver":{"vulnerable":["<1.10.10",">=1.11.0 <1.11.6",">=1.12.0 <1.12.4",">=1.13.0 <1.13.1"]}},
      {"id":"npm:dojo:20100614-6","severity":"medium","semver":{"vulnerable":["<1.4.2"]}},
      {"id":"npm:dojo:20100614","severity":"medium","semver":{"vulnerable":[">=0.4.0 <0.4.4",">=1.0.0 <1.0.3",">=1.1.0 <1.1.2",">=1.2.0 <1.2.4",">=1.3.0 <1.3.3",">=1.4.0 <1.4.2"]}}
    ],
    "foundation-sites":[
      {"id":"npm:foundation-sites:20170802","severity":"medium","semver":{"vulnerable":["<6.0.0"]}},
      {"id":"npm:foundation-sites:20150619","severity":"medium","semver":{"vulnerable":["<5.5.3"]}},
      {"id":"npm:foundation-sites:20120717","severity":"medium","semver":{"vulnerable":[">=3.0.0 <3.0.6"]}}
    ],
    "google-closure-library":[
      {"id":"SNYK-JS-GOOGLECLOSURELIBRARY-561341","severity":"medium","semver":{"vulnerable":["<20200315.0.0"]}},
      {"id":"SNYK-JS-GOOGLECLOSURELIBRARY-174519","severity":"medium","semver":{"vulnerable":[">=20190121.0.0 <20190301.0.0"]}}
    ],
    "gsap":[
      {"id":"SNYK-JS-GSAP-1054614","severity":"high","semver":{"vulnerable":["<3.6.0"]}}
    ],
    "handlebars":[
      {"id":"SNYK-JS-HANDLEBARS-1056767","severity":"medium","semver":{"vulnerable":["<4.7.7"]}},
      {"id":"SNYK-JS-HANDLEBARS-567742","severity":"medium","semver":{"vulnerable":["<4.6.0"]}},
      {"id":"SNYK-JS-HANDLEBARS-534988","severity":"high","semver":{"vulnerable":[">=4.0.0 <4.5.3","<3.0.8"]}},
      {"id":"SNYK-JS-HANDLEBARS-534478","severity":"high","semver":{"vulnerable":[">=4.0.0 <4.5.3","<3.0.8"]}},
      {"id":"SNYK-JS-HANDLEBARS-480388","severity":"high","semver":{"vulnerable":[">=4.0.0 <4.4.5"]}},
      {"id":"SNYK-JS-HANDLEBARS-469063","severity":"high","semver":{"vulnerable":[">=4.0.0 <4.3.0","<3.8.0"]}},
      {"id":"SNYK-JS-HANDLEBARS-174183","severity":"high","semver":{"vulnerable":[">=3.0.0 <3.0.7",">=4.1.0 <4.1.2",">=4.0.0 <4.0.14"]}},
      {"id":"SNYK-JS-HANDLEBARS-173692","severity":"high","semver":{"vulnerable":["<4.0.14",">=4.1.0 <4.1.2"]}},
      {"id":"npm:handlebars:20151207","severity":"medium","semver":{"vulnerable":["<4.0.0"]}},
      {"id":"npm:handlebars:20110425","severity":"medium","semver":{"vulnerable":["<=1.0.0-beta.3"]}}
    ],
    "highcharts":[
      {"id":"SNYK-JS-HIGHCHARTS-1018906","severity":"medium","semver":{"vulnerable":["<9.0.0"]}},
      {"id":"SNYK-JS-HIGHCHARTS-571995","severity":"high","semver":{"vulnerable":["<7.2.2",">=8.0.0 <8.1.1"]}},
      {"id":"npm:highcharts:20180225","severity":"high","semver":{"vulnerable":["<6.1.0"]}}
    ],
    "jquery":[
      {"id":"SNYK-JS-JQUERY-569619","severity":"medium","semver":{"vulnerable":["<1.9.0"]}},
      {"id":"SNYK-JS-JQUERY-567880","severity":"medium","semver":{"vulnerable":[">=1.2.0 <3.5.0"]}},
      {"id":"SNYK-JS-JQUERY-565129","severity":"medium","semver":{"vulnerable":[">=1.0.3 <3.5.0"]}},
      {"id":"SNYK-JS-JQUERY-174006","severity":"medium","semver":{"vulnerable":["<3.4.0"]}},
      {"id":"npm:jquery:20160529","severity":"low","semver":{"vulnerable":[">=3.0.0-rc1 <3.0.0"]}},
      {"id":"npm:jquery:20150627","severity":"medium","semver":{"vulnerable":["<1.12.2",">=1.12.3 <2.2.2",">=2.2.3 <3.0.0"]}},
      {"id":"npm:jquery:20140902","severity":"medium","semver":{"vulnerable":[">=1.4.2 <1.6.2"]}},
      {"id":"npm:jquery:20120206","severity":"medium","semver":{"vulnerable":["<1.9.1"]}},
      {"id":"npm:jquery:20110606","severity":"medium","semver":{"vulnerable":["<1.6.3"]}}
    ],
    "jquery-mobile":[
      {"id":"SNYK-JS-JQUERYMOBILE-174599","severity":"medium","semver":{"vulnerable":["<=1.5.0-alpha.1"]}},
      {"id":"npm:jquery-mobile:20120802","severity":"medium","semver":{"vulnerable":["<1.2.0"]}}
    ],
    "jquery-ui":[
      {"id":"npm:jquery-ui:20121127","severity":"medium","semver":{"vulnerable":["<1.10.0"]}},
      {"id":"npm:jquery-ui:20100903","severity":"medium","semver":{"vulnerable":["<1.10.0"]}},
      {"id":"npm:jquery-ui:20160721","severity":"high","semver":{"vulnerable":["<1.12.0"]}}
    ],
    "knockout":[
      {"id":"npm:knockout:20180213","severity":"medium","semver":{"vulnerable":["<3.5.0-beta"]}},
      {"id":"npm:knockout:20130701","severity":"medium","semver":{"vulnerable":[">=2.1.0-pre <3.0.0"]}}
    ],
    "lodash":[
      {"id":"SNYK-JS-LODASH-1040724","severity":"high","semver":{"vulnerable":["<4.17.21"]}},
      {"id":"SNYK-JS-LODASH-1018905","severity":"medium","semver":{"vulnerable":["<4.17.21"]}},
      {"id":"SNYK-JS-LODASH-608086","severity":"high","semver":{"vulnerable":["<4.17.17"]}},
      {"id":"SNYK-JS-LODASH-590103","severity":"high","semver":{"vulnerable":["<4.17.20"]}},
      {"id":"SNYK-JS-LODASH-567746","severity":"medium","semver":{"vulnerable":["<4.17.16"]}},
      {"id":"SNYK-JS-LODASH-450202","severity":"high","semver":{"vulnerable":["<4.17.12"]}},
      {"id":"SNYK-JS-LODASH-73639","severity":"medium","semver":{"vulnerable":["<4.17.11"]}},
      {"id":"SNYK-JS-LODASH-73638","severity":"high","semver":{"vulnerable":["<4.17.11"]}},
      {"id":"npm:lodash:20180130","severity":"medium","semver":{"vulnerable":["<4.17.5"]}}
    ],
    "moment":[
      {"id":"npm:moment:20170905","severity":"low","semver":{"vulnerable":["<2.19.3"]}},
      {"id":"npm:moment:20161019","severity":"medium","semver":{"vulnerable":["<2.15.2"]}},
      {"id":"npm:moment:20160126","severity":"medium","semver":{"vulnerable":["<2.11.2"]}}
    ],
    "mustache":[
      {"id":"npm:mustache:20151207","severity":"medium","semver":{"vulnerable":["<2.2.1"]}},
      {"id":"npm:mustache:20110814","severity":"medium","semver":{"vulnerable":["< 0.3.1"]}}
    ],
    "next":[
      {"id":"SNYK-JS-NEXT-1063481","severity":"medium","semver":{"vulnerable":[">=9.5.0 <9.5.4"]}},
      {"id":"SNYK-JS-NEXT-571938","severity":"high","semver":{"vulnerable":["<5.1.0"]}},
      {"id":"SNYK-JS-NEXT-561584","severity":"medium","semver":{"vulnerable":["<9.3.2"]}},
      {"id":"SNYK-JS-NEXT-174590","severity":"high","semver":{"vulnerable":["<2.4.1"]}},
      {"id":"SNYK-JS-NEXT-72454","severity":"medium","semver":{"vulnerable":[">=7.0.0 <7.0.2"]}},
      {"id":"npm:next:20180124","severity":"high","semver":{"vulnerable":["<4.2.3"]}},
      {"id":"npm:next:20170607","severity":"medium","semver":{"vulnerable":["<2.4.3"]}},
      {"id":"npm:next:20170601","severity":"high","semver":{"vulnerable":["<2.4.1",">=3.0.0-beta1 <3.0.0-beta7"]}}
    ],
    "react":[
      {"id":"npm:react:20150318","severity":"high","semver":{"vulnerable":[">=0.0.1 <0.14.0"]}},
      {"id":"npm:react:20131217","severity":"medium","semver":{"vulnerable":[">=0.5.0 <0.5.2",">=0.4.0 <0.4.2"]}}
    ],
    "riot":[
      {"id":"npm:riot:20131114","severity":"medium","semver":{"vulnerable":["<0.9.6"]}}
    ],
    "socket.io":[
      {"id":"SNYK-JS-SOCKETIO-1024859","severity":"medium","semver":{"vulnerable":["<2.4.0"]}},
      {"id":"npm:socket.io:20120417","severity":"medium","semver":{"vulnerable":["<0.9.6"]}},
      {"id":"npm:socket.io:20120323","severity":"medium","semver":{"vulnerable":["<0.9.7"]}}
    ],
    "three":[
      {"id":"SNYK-JS-THREE-1064931","severity":"high","semver":{"vulnerable":["<0.125.0"]}}
    ],
    "underscore":[
      {"id":"SNYK-JS-UNDERSCORE-1080984","severity":"low","semver":{"vulnerable":[">=1.13.0-0 <1.13.0-2",">=1.3.2 <1.12.1"]}}
    ],
    "vue":[
      {"id":"npm:vue:20170829","severity":"medium","semver":{"vulnerable":["<2.4.3"]}},
      {"id":"npm:vue:20170401","severity":"medium","semver":{"vulnerable":["<2.3.0-beta.1"]}},
      {"id":"npm:vue:20180802","severity":"medium","semver":{"vulnerable":["<2.5.17"]}},
      {"id":"npm:vue:20180222","severity":"low","semver":{"vulnerable":["<2.5.14"]}}
    ],
    "yui":[
      {"id":"npm:yui:20130604","severity":"medium","semver":{"vulnerable":[">=3.0.0 <3.10.1","=3.10.2"]}},
      {"id":"npm:yui:20130515","severity":"medium","semver":{"vulnerable":["<3.10.0 >=3.0.0"]}},
      {"id":"npm:yui:20121030","severity":"medium","semver":{"vulnerable":["<3.0.0 >=2.4.0"]}},
      {"id":"npm:yui:20120428","severity":"medium","semver":{"vulnerable":["<3.5.1 >=3.5.0-PR1"]}},
      {"id":"npm:yui:20101025","severity":"medium","semver":{"vulnerable":["<2.8.2 >=2.4.0"]}}
    ]
}
var snapshot = {
	npm: npm
};

var vulnsData = /*#__PURE__*/Object.freeze({
  __proto__: null,
  npm: npm,
  'default': snapshot
});

var UNKNOWN_VERSION = null;
var d41d8cd98f00b204e9800998ecf8427e_LibraryDetectorTests = {

    'GWT': {
        id: 'gwt',
        icon: 'gwt',
        url: 'http://www.gwtproject.org/',
        test: function(win) {
            // pretty complicated, many possible tell tales
            var doc = win.document,
                hasHistFrame = doc.getElementById('__gwt_historyFrame'),
                hasGwtUid = doc.gwt_uid,
                hasBodyListener = doc.body.__listener,
                hasBodyEventBits = doc.body.__eventBits,
                hasModules = win.__gwt_activeModules,
                hasJsonP = win.__gwt_jsonp__,
                hasRootWinApp = win.__gwt_scriptsLoaded || win.__gwt_stylesLoaded || win.__gwt_activeModules;

            // use the many possible indicators
            if(hasHistFrame || hasGwtUid || hasBodyListener || hasBodyEventBits || hasModules || hasJsonP || hasRootWinApp) {

                // carefully look at frames, but only if certain is GWT frame
                var frames = doc.getElementsByTagName('iframe'),
                    gwtVersion = UNKNOWN_VERSION;
                for(var n=0; n<frames.length; n++) {
                    // catch security access errors
                    try {
                        var hasNegativeTabIndex = frames[n].tabIndex < 0; // on for GWT
                        if(hasNegativeTabIndex && frames[n].contentWindow && frames[n].contentWindow.$gwt_version) {
                            gwtVersion = frames[n].contentWindow.$gwt_version;
                            break;
                        }
                    }
                    catch(e) {}
                }

                if(gwtVersion=='0.0.999') {
                  gwtVersion = 'Google Internal';
                }

                return { version: gwtVersion };
            }
            return false;
        }
    },

    'Ink': {
        id: 'ink',
        icon: 'ink',
        url: 'http://ink.sapo.pt/',
        test: function(win) {
            if (win.Ink && win.Ink.createModule) {
                return { version: UNKNOWN_VERSION };
            }
            return false;
        }
    },

    'Vaadin': {
        id: 'vaadin',
        icon: 'vaadin',
        url: 'https://vaadin.com/',
        test: function(win) {
            if (win.vaadin && win.vaadin.registerWidgetset) {
                return { version: UNKNOWN_VERSION };
            }
            return false;
        }
    },

    'Bootstrap': {
        id: 'bootstrap',
        icon: 'bootstrap',
        url: 'http://getbootstrap.com/',
        npm: 'bootstrap',
        // look for a function Boostrap has added to jQuery - regex for BS 2 & 3
        test: function(win) {
            var jQueryAvailable = win.$ && win.$.fn,
                RE_PREFIX_V2 = '\\$this\\.data\\((?:\'|")',
                RE_PREFIX_V3 = '\\$this\\.data\\((?:\'|")(?:bs\\.){1}',
                bootstrapComponents = [
                    'affix', 'alert', 'button', 'carousel', 'collapse', 'dropdown',
                    'modal', 'popover', 'scrollspy', 'tab', 'tooltip'
                ];

            if(jQueryAvailable) {
                var bootstrapVersion;

                bootstrapComponents.some(function(component) {
                    if(win.$.fn[component]) {
                        // Bootstrap >= 3.2.0 detection
                        if(win.$.fn[component].Constructor && win.$.fn[component].Constructor.VERSION) {
                            bootstrapVersion = win.$.fn[component].Constructor.VERSION;
                            return true;
                        // Bootstrap >= 2.0.0 and <= 3.1.0 detection
                        } else if(new RegExp(RE_PREFIX_V3 + component).test(win.$.fn[component].toString())) {
                            bootstrapVersion = '>= 3.0.0 & <= 3.1.1';
                            return true;
                        // Bootstrap < 3.1.0 detection
                        } else if(new RegExp(RE_PREFIX_V2 + component).test(win.$.fn[component].toString())) {
                            bootstrapVersion = '>= 2.0.0 & <= 2.3.2';
                            return true;
                        }
                    }

                    return false;
                });

                if (bootstrapVersion) {
                    return { version: bootstrapVersion };
                }
            }

            return false;
        }
    },

    'Zurb': {
        id: 'zurb',
        icon: 'zurb',
        url: 'https://foundation.zurb.com/',
        npm: 'foundation-sites',
        test: function(win) {
            if(win.Foundation && win.Foundation.Toggler) {
                return { version: win.Foundation.version || UNKNOWN_VERSION };
            }
            return false;
        }
    },

    'Polymer': {
        id: 'polymer',
        icon: 'polymer',
        url: 'https://www.polymer-project.org/',
        npm: '@polymer/polymer',
        test: function(win) {
            if(win.Polymer && win.Polymer.dom) {
                return { version: win.Polymer.version || UNKNOWN_VERSION };
            }
            return false;
        }
    },

    'Highcharts': {
        id: 'highcharts',
        icon: 'highcharts',
        url: 'http://www.highcharts.com',
        npm: 'highcharts',
        test: function(win) {
            if(win.Highcharts && win.Highcharts.Point) {
                return { version: win.Highcharts.version || UNKNOWN_VERSION };
            }
            return false;
        }
    },

    'InfoVis': {
        id: 'jit',
        icon: 'jit',
        url: 'http://philogb.github.com/jit/',
        test: function test(win) {
            if(win.$jit && win.$jit.PieChart) {
                return { version: win.$jit.version || UNKNOWN_VERSION };
            }
            return false;
        }
    },

    'FlotCharts': {
        id: 'flotcharts',
        icon: 'flotcharts',
        url: 'http://www.flotcharts.org/',
        npm: 'flot',
        test: function(win) {
            if(win.$ && win.$.plot) {
                return { version: win.$.plot.version || UNKNOWN_VERSION};
            }
            return false;
        }
    },

    'CreateJS': {
        id: 'createjs',
        icon: 'createjs',
        url: 'https://createjs.com/',
        npm: 'createjs',
        test: function(win) {
            if(win.createjs && win.createjs.promote) {
                return { version: UNKNOWN_VERSION}; // no version info available
            }
            return false;
        }
    },

    'Google Maps': {
        id: 'gmaps',
        icon: 'gmaps',
        url: 'https://developers.google.com/maps/',
        test: function(win) {
            if (win.google && win.google.maps) {
                return { version: win.google.maps.version || UNKNOWN_VERSION };
            }
            return false;
        }
    },

    'jQuery': {
        id: 'jquery',
        icon: 'jquery',
        url: 'http://jquery.com',
        npm: 'jquery',
        test: function(win) {
            var jq = win.jQuery || win.$;
            if (jq && jq.fn && jq.fn.jquery) {
                return { version: jq.fn.jquery.replace(/[^\d+\.+]/g, '') || UNKNOWN_VERSION};
            }
            return false;
        }
    },

    'jQuery (Fast path)': {
        id: 'jquery-fast',
        icon: 'jquery',
        url: 'http://jquery.com',
        npm: 'jquery',
        test: function (win) {
            var jq = win.jQuery || win.$;
            if (jq && jq.fn) {
                return { version: UNKNOWN_VERSION };
            }
            return false;
        }
    },

    'jQuery UI': {
        id: 'jquery_ui',
        icon: 'jquery_ui',
        url: 'http://jqueryui.com',
        npm: 'jquery-ui',
        test: function(win) {
            var jq = win.jQuery || win.$ || win.$jq || win.$j;
            if(jq && jq.fn && jq.fn.jquery && jq.ui) {
                var plugins = 'accordion,datepicker,dialog,draggable,droppable,progressbar,resizable,selectable,slider,menu,grid,tabs'.split(','), concat = [];
                for (var i=0; i < plugins.length; i++) { if(jq.ui[plugins[i]]) concat.push(plugins[i].substr(0,1).toUpperCase() + plugins[i].substr(1)); }
                return { version: jq.ui.version || UNKNOWN_VERSION, details: concat.length ? 'Plugins used: '+concat.join(',') : '' };
            }
            return false;
        }
    },

    'Dojo': {
        id: 'dojo',
        icon: 'dojo',
        url: 'http://dojotoolkit.org',
        npm: 'dojo',
        test: function(win) {
            if(win.dojo && win.dojo.delegate) {
                var version = win.dojo.version ? win.dojo.version.toString() : UNKNOWN_VERSION;
                return { version: version, details: 'Details: '+(win.dijit ? 'Uses Dijit' : 'none') };
            }
            return false;
        }
    },

    'Prototype': {
        id: 'prototype',
        icon: 'prototype',
        url: 'http://prototypejs.org',
        test: function(win) {
            if(win.Prototype && win.Prototype.BrowserFeatures) {
                return { version: win.Prototype.Version || UNKNOWN_VERSION };
            }
            return false;
        }
    },

    'Scriptaculous': {
        id: 'scriptaculous',
        icon: 'scriptaculous',
        url: 'http://script.aculo.us',
        test: function(win) {
            if(win.Scriptaculous && win.Scriptaculous.load) {
                return { version: win.Scriptaculous.Version || UNKNOWN_VERSION };
            }
            return false;
        }
    },

    'MooTools': {
        id: 'mootools',
        icon: 'mootools',
        url: 'https://mootools.net/',
        test: function(win) {
            if(win.MooTools && win.MooTools.build) {
                return { version: win.MooTools.version || UNKNOWN_VERSION };
            }
            return false;
        }
    },

    'Spry': {
        id: 'spry',
        icon: 'spry',
        url: 'http://labs.adobe.com/technologies/spry',
        test: function(win) {
            if (win.Spry && win.Spry.Data) {
                return { version: UNKNOWN_VERSION };
            }
            return false;
        }
    },

    'YUI 2': {
        id: 'yui',
        icon: 'yui',
        url: 'http://developer.yahoo.com/yui/2/',
        test: function(win) {
            if (win.YAHOO && win.YAHOO.util) {
                return { version: win.YAHOO.VERSION || UNKNOWN_VERSION };
            }
            return false;
        }
    },

    'YUI 3': {
        id: 'yui3',
        icon: 'yui3',
        url: 'https://yuilibrary.com/',
        npm: 'yui',
        test: function(win) {
            if (win.YUI && win.YUI.Env) {
                return { version: win.YUI.version || UNKNOWN_VERSION };
            }
            return false;
        }
    },

    'Qooxdoo': {
        id: 'qooxdoo',
        icon: 'qooxdoo',
        url: 'http://www.qooxdoo.org/',
        npm: 'qooxdoo',
        test: function(win) {
            if(win.qx && win.qx.Bootstrap) {
                return { version: UNKNOWN_VERSION };
            }
            return false;
        }
    },

    'Ext JS': {
        id: 'extjs',
        icon: 'extjs',
        url: 'https://www.sencha.com/products/extjs/',
        test: function(win) {
            if (win.Ext && win.Ext.versions) {
                return { version: win.Ext.versions.core.version };
            }
            else if(win.Ext) {
                return { version: win.Ext.version || UNKNOWN_VERSION };
            }
            return false;
        }
    },

    'base2': {
        id: 'base2',
        icon: 'base2',
        url: 'http://code.google.com/p/base2',
        test: function(win) {
            if(win.base2 && win.base2.dom) {
                return { version: win.base2.version || UNKNOWN_VERSION };
            }
            return false;
        }
    },

    'Closure Library': {
        id: 'closure',
        icon: 'closure',
        url: 'https://developers.google.com/closure/library/',
        npm: 'google-closure-library',
        test: function(win) {
            if(win.goog && win.goog.provide) {
                return { version: UNKNOWN_VERSION };
            }
            return false;
        }
    },

    'Rapha&euml;l': {
        id: 'raphael',
        icon: 'raphael',
        url: 'http://dmitrybaranovskiy.github.io/raphael/',
        test: function(win) {
            if (win.Raphael && win.Raphael.circle) {
                return { version: win.Raphael.version || UNKNOWN_VERSION };
            }
            return false;
        }
    },

    'React': {
        id: 'react',
        icon: 'react',
        url: 'https://reactjs.org/',
        npm: 'react',
        test: function(win) {
            function isMatch(node) {
                return node!=null && node._reactRootContainer!=null;
            }
            function nodeFilter(node) {
                return isMatch(node) ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
            }
            var reactRoot = document.getElementById('react-root');
            var altHasReact = document.querySelector('*[data-reactroot]');
            var bodyReactRoot = isMatch(document.body) || isMatch(document.body.firstElementChild);
            var hasReactRoot = bodyReactRoot|| document.createTreeWalker(document.body, NodeFilter.SHOW_ELEMENT, nodeFilter).nextNode() != null;
            if (hasReactRoot || reactRoot && reactRoot.innerText.length > 0 || altHasReact || win.React && win.React.Component) {
                return { version: win.React && win.React.version || UNKNOWN_VERSION };
            }
            return false;
        }
    },

    'React (Fast path)': {
        id: 'react-fast',
        icon: 'react',
        url: 'https://reactjs.org/',
        npm: 'react',
        test: function (win) {
            function isMatch(node) {
                return node != null && node._reactRootContainer != null;
            }
            var reactRoot = document.getElementById('react-root');
            var altHasReact = document.querySelector('*[data-reactroot]');
            var hasReactRoot = isMatch(document.body) || isMatch(document.body.firstElementChild);
            if (hasReactRoot || reactRoot || altHasReact || win.React) {
                return { version: win.React && win.React.version || UNKNOWN_VERSION };
            }
            return false;
        }
    },

    'Next.js': {
        id: 'next',
        icon: 'next',
        url: 'https://nextjs.org/',
        npm: 'next',
        test: function(win) {
            if (win.__NEXT_DATA__ && win.__NEXT_DATA__.buildId) {
                return { version: window.next && window.next.version || UNKNOWN_VERSION };
            }
            return false;
        }
    },

    'Next.js (Fast path)': {
        id: 'next-fast',
        icon: 'next',
        url: 'https://nextjs.org/',
        npm: 'next',
        test: function (win) {
            if (win.__NEXT_DATA__) {
                return { version: UNKNOWN_VERSION };
            }
            return false;
        }
    },

    'Preact': {
        id: 'preact',
        icon: 'preact',
        url: 'https://preactjs.com/',
        npm: 'preact',
        test: function(win) {
            var expando = typeof Symbol!='undefined' && Symbol.for && Symbol.for('preactattr');
            function isMatch(node) {
                if ('__k' in node && 'props' in node.__k && 'type' in node.__k) {
                    return true;
                }
                return '_component' in node || '__preactattr_' in node || expando && node[expando]!=null;
            }
            function getMatch(node) {
                return node!=null && isMatch(node) && node;
            }
            function nodeFilter(node) {
                return isMatch(node) ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
            }
            var preactRoot = getMatch(document.body) || getMatch(document.body.firstElementChild);
            if (!preactRoot) {
                preactRoot = document.createTreeWalker(document.body, NodeFilter.SHOW_ELEMENT, nodeFilter).nextNode();
            }
            if (preactRoot || win.preact) {
                var version = UNKNOWN_VERSION;
                if (preactRoot) {
                    if ('__k' in preactRoot) {
                        version = '10';
                    }
                    if ('__preactattr_' in preactRoot) {
                        version = '8';
                    }
                    if (expando && preactRoot[expando]!=null) {
                        version = '7';
                    }
                }
                return { version: version };
            }
            return false;
        }
    },

    'Preact (Fast path)': {
        id: 'preact-fast',
        icon: 'preact',
        url: 'https://preactjs.com/',
        npm: 'preact',
        test: function (win) {
            function isMatch(node) {
                return node._component != null || node.__preactattr_ != null;
            }
            function getMatch(node) {
                return node != null && isMatch(node);
            }
            var preactRoot = getMatch(document.body) || getMatch(document.body.firstElementChild);
            if (preactRoot || win.preact) {
                var version = UNKNOWN_VERSION;
                return { version: version };
            }
            return false;
        }
    },

    'Modernizr': {
        id: 'modernizr',
        icon: 'modernizr',
        url: 'https://modernizr.com/',
        npm: 'modernizr',
        test: function(win) {
            if (win.Modernizr && win.Modernizr.addTest) {
                return { version: win.Modernizr._version || UNKNOWN_VERSION };
            }
            return false;
        }
    },

    'Processing.js': {
        id: 'processingjs',
        icon: 'processingjs',
        url: 'http://processingjs.org',
        npm: 'processing-js',
        test: function(win) {
            if(win.Processing && win.Processing.box) {
                return { version: Processing.version || UNKNOWN_VERSION };
            }
            return false;
        }
    },

    'Backbone': {
        id: 'backbone',
        icon: 'backbone',
        url: 'http://backbonejs.org/',
        npm: 'backbone',
        test: function(win) {
            if (win.Backbone && win.Backbone.Model.extend) {
                return {version: win.Backbone.VERSION || UNKNOWN_VERSION};
            }
            return false;
        }
    },

    'Leaflet': {
        id: 'leaflet',
        icon: 'leaflet',
        url: 'http://leafletjs.com',
        npm: 'leaflet',
        test: function(win) {
            // Leaflet 3.1 uses L.Marker and L.VERSION; later versions use L.marker and L.version
            if (win.L && win.L.GeoJSON && (win.L.marker || win.L.Marker)) {
                return { version: win.L.version || win.L.VERSION || UNKNOWN_VERSION };
            }
            return false;
        }
    },

    'Mapbox': {
        id: 'mapbox',
        icon: 'mapbox',
        url: 'https://www.mapbox.com/',
        npm: 'mapbox-gl',
        test: function(win) {
            if (win.L && win.L.mapbox && win.L.mapbox.geocoder) {
                return { version: win.L.mapbox.VERSION || UNKNOWN_VERSION };
            }
            return false;
        }
    },

    'Lo-Dash': {
        id: 'lodash',
        icon: 'lodash',
        url: 'https://lodash.com/',
        npm: 'lodash',
        test: function(win) {
            var _ = typeof (_ = win._) == 'function' && _,
                chain = typeof (chain = _ && _.chain) == 'function' && chain,
                wrapper = (chain || _ || function() { return {}; })(1);

            if (_ && wrapper.__wrapped__) {
                return { version: _.VERSION || UNKNOWN_VERSION };
            }
            return false;
        }
    },

    'Underscore': {
        id: 'underscore',
        icon: 'underscore',
        url: 'http://underscorejs.org/',
        npm: 'underscore',
        test: function(win) {
            if (win._ && typeof win._.tap === 'function' &&
                !d41d8cd98f00b204e9800998ecf8427e_LibraryDetectorTests['Lo-Dash'].test(win)) {
                return {version: win._.VERSION || UNKNOWN_VERSION};
            }
            return false;
        }
    },

    'Sammy': {
        id: 'sammy',
        icon: 'sammy',
        url: 'http://sammyjs.org',
        test: function(win) {
            if (win.Sammy && win.Sammy.Application.curry) {
                return {version: win.Sammy.VERSION || UNKNOWN_VERSION};
            }
            return false;
        }
    },

    'Rico': {
        id: 'rico',
        icon: 'rico',
        url: 'http://openrico.sourceforge.net/examples/index.html',
        test:  function(win) {
            if (win.Rico && window.Rico.checkIfComplete) {
                return {version: win.Rico.Version || UNKNOWN_VERSION};
            }
            return false;
        }
    },

    'MochiKit': {
        id: 'mochikit',
        icon: 'mochikit',
        url: 'https://mochi.github.io/mochikit/',
        test: function(win) {
            if (win.MochiKit && win.MochiKit.Base.module) {
                return {version: MochiKit.VERSION || UNKNOWN_VERSION};
            }
            return false;
        }
    },

    'gRapha&euml;l': {
        id: 'graphael',
        icon: 'graphael',
        url: 'https://github.com/DmitryBaranovskiy/g.raphael',
        test: function(win) {
            if (win.Raphael && win.Raphael.fn.g) {
                return {version: UNKNOWN_VERSION};
            }
            return false;
        }
    },

    'Glow': {
        id: 'glow',
        icon: 'glow',
        url: 'http://www.bbc.co.uk/glow/',
        test: function(win) {
            if (win.gloader && win.gloader.getRequests) {
                return {version: UNKNOWN_VERSION};
            }
            else if (win.glow && win.glow.dom) {
                return {version: win.glow.VERSION || UNKNOWN_VERSION};
            }
            else if (win.Glow) {
                return {version: win.Glow.version || UNKNOWN_VERSION};
            }
            return false;
        }
    },

    'Socket.IO': {
        id: 'socketio',
        icon: 'socketio', // currently has no icon
        url: 'https://socket.io/',
        npm: 'socket.io',
        test: function(win) {
            // version 0.6.2 uses only io.Socket; more recent versions also have io.sockets
            if (win.io && (win.io.sockets || win.io.Socket)) {
                return {version: win.io.version || UNKNOWN_VERSION};
            }
            return false;
        }
    },

    'Mustache': {
        id: 'mustache',
        icon: 'mustache',
        url: 'http://mustache.github.io/',
        npm: 'mustache',
        test: function(win) {
            if (win.Mustache && win.Mustache.to_html) {
                return {version: win.Mustache.version || UNKNOWN_VERSION};
            }
            return false;
        }
    },

    'Fabric.js': {
        id: 'fabricjs',
        icon: 'icon38', // currently has no icon
        url: 'http://fabricjs.com/',
        npm: 'fabric',
        test: function(win) {
            if (win.fabric && win.fabric.util) {
                return {version: win.fabric.version || UNKNOWN_VERSION};
            }
            return false;
        }
    },

    'FuseJS': {
        id: 'fusejs',
        icon: 'fusejs',
        url: 'http://fusejs.io/',
        npm: 'fuse.js',
        test: function(win) {
            if (win.Fuse) {
                return {version: UNKNOWN_VERSION};
            }
            return false;
        }
    },

    'Tween.js': {
        id: 'tweenjs',
        icon: 'icon38', // currently has no icon
        url: 'https://github.com/tweenjs/tween.js',
        npm: 'tween.js',
        test: function(win) {
            if (win.TWEEN && win.TWEEN.Easing) {
                return {version: UNKNOWN_VERSION};
            }
            return false;
        }
    },

    'SproutCore': {
       id: 'sproutcore',
       icon: 'sproutcore',
       url: 'http://sproutcore.com/',
       test: function(win) {
           if (win.SC && win.SC.Application) {
               return {version: UNKNOWN_VERSION};
           }
           return false;
       }
    },

    'Zepto.js': {
       id: 'zepto',
       icon: 'zepto',
       url: 'http://zeptojs.com',
       npm: 'zepto',
       test: function(win) {
           if (win.Zepto && win.Zepto.fn) {
               return {version: UNKNOWN_VERSION};
           }
           return false;
       }
    },

    'three.js': {
       id: 'threejs',
       icon: 'icon38', // currently has no icon
       url: 'https://threejs.org/',
       npm: 'three',
       test: function(win) {
           if (win.THREE && win.THREE.REVISION) {
               return {version: 'r' + win.THREE.REVISION};
           }
           else if (win.THREE) {
               return {version: UNKNOWN_VERSION};
           }
           return false;
       }
    },

    'PhiloGL': {
       id: 'philogl',
       icon: 'philogl',
       url: 'http://www.senchalabs.org/philogl/',
       npm: 'philogl',
       test: function(win) {
           if (win.PhiloGL && win.PhiloGL.Camera) {
               return {version: win.PhiloGL.version || UNKNOWN_VERSION};
           }
           return false;
       }
    },

    'CamanJS': {
        id: 'camanjs',
        icon: 'camanjs',
        url: 'http://camanjs.com/',
        npm: 'caman',
        test: function(win) {
            if (win.Caman && win.Caman.version) {
                return {version: win.Caman.version.release};
            }
            else if (win.Caman) {
                return {version: UNKNOWN_VERSION};
            }
            return false;
        }
    },

    'yepnope': {
        id: 'yepnope',
        icon: 'yepnope',
        url: 'http://yepnopejs.com/',
        test: function(win) {
            if (win.yepnope && win.yepnope.injectJs) {
                return {version: UNKNOWN_VERSION};
            }
            return false;
        }
    },

    'LABjs': {
        id: 'labjs',
        icon: 'icon38',
        url: 'https://github.com/getify/LABjs',
        test: function(win) {
            if (win.$LAB && win.$LAB.setOptions) {
                return {version: UNKNOWN_VERSION};
            }
            return false;
        }
    },

    'Head JS': {
        id: 'headjs',
        icon: 'headjs',
        url: 'http://headjs.com/',
        npm: 'headjs',
        test: function(win) {
            if (win.head && win.head.js) {
                return {version: UNKNOWN_VERSION};
            }
            return false;
        }
    },

    'ControlJS': {
        id: 'controljs',
        icon: 'icon38',
        url: 'http://stevesouders.com/controljs/',
        test: function(win) {
            if (win.CJS && win.CJS.start) {
                return {version: UNKNOWN_VERSION};
            }
            return false;
        }
    },

    'RequireJS': {
        id: 'requirejs',
        icon: 'requirejs',
        url: 'http://requirejs.org/',
        npm: 'requirejs',
        test: function(win) {
            var req = win.require || win.requirejs;
            if (req && (req.load || (req.s && req.s.contexts && req.s.contexts._ && (req.s.contexts._.loaded || req.s.contexts._.load)))) {
                return { version: req.version || UNKNOWN_VERSION };
            }
            return false;
        }
    },

    'RightJS': {
        id: 'rightjs',
        icon: 'rightjs',
        url: 'http://rightjs.org/',
        test: function(win) {
            if (win.RightJS && win.RightJS.isNode) {
                return { version: win.RightJS.version || UNKNOWN_VERSION };
            }
            return false;
        }
    },

    'jQuery Tools': {
       id: 'jquerytools',
       icon: 'jquerytools',
       url: 'http://jquerytools.github.io/',
       test: function(win) {
            var jq = win.jQuery || win.$;
            if(jq && jq.tools) {
               return { version: jq.tools.version || UNKNOWN_VERSION };
           }
           return false;
       }
    },

    'Pusher': {
       id: 'pusher',
       icon: 'pusher',
       url: 'https://pusher.com/docs/',
       npm: 'pusher-js',
       test: function(win) {
            if(win.Pusher && win.Pusher.Channel) {
               return { version: win.Pusher.VERSION || UNKNOWN_VERSION };
           }
           return false;
       }
    },

    'Paper.js': {
       id: 'paperjs',
       icon: 'paperjs',
       url: 'http://paperjs.org/',
       npm: 'paper',
       test: function(win) {
            if(win.paper && win.paper.Point) {
               return { version: win.paper.version || UNKNOWN_VERSION };
           }
           return false;
       }
    },

    'Swiffy': {
       id: 'swiffy',
       icon: 'icon38',
       url: 'https://developers.google.com/swiffy/',
       test: function(win) {
            if(win.swiffy && win.swiffy.Stage) {
               return { version: UNKNOWN_VERSION };
           }
           return false;
       }
    },

    'Move': {
       id: 'move',
       icon: 'move',
       url: 'https://github.com/rsms/move',
       npm: 'move',
       test: function(win) {
            if(win.move && win.move.compile) {
               return { version: win.move.version() || UNKNOWN_VERSION };
           }
           return false;
       }
    },

    'AmplifyJS': {
       id: 'amplifyjs',
       icon: 'amplifyjs',
       url: 'http://amplifyjs.com/',
       npm: 'amplifyjs',
       test: function(win) {
            if(win.amplify && win.amplify.publish) {
               return { version: UNKNOWN_VERSION };
           }
           return false;
       }
    },

    'Popcorn.js': {
       id: 'popcornjs',
       icon: 'popcornjs',
       url: 'https://github.com/mozilla/popcorn-js/',
       test: function(win) {
            if (win.Popcorn && win.Popcorn.Events) {
               return { version: win.Popcorn.version || UNKNOWN_VERSION };
           }
           return false;
       }
    },

    'D3': {
        id: 'd3',
        icon: 'd3',
        url: 'https://d3js.org/',
        npm: 'd3',
        test: function(win) {
            if (win.d3 && win.d3.select) {
                return { version: win.d3.version || UNKNOWN_VERSION };
            }
            return false;
        }
    },

    'Handlebars': {
        id: 'handlebars',
        icon: 'handlebars',
        url: 'http://handlebarsjs.com/',
        npm: 'handlebars',
        test: function(win) {
            if(win.Handlebars && win.Handlebars.compile) {
                return { version: win.Handlebars.VERSION || UNKNOWN_VERSION };
            }
            return false;
        }
    },

    'Knockout': {
        id: 'knockout',
        icon: 'knockout',
        url: 'http://knockoutjs.com/',
        npm: 'knockout',
        test: function(win) {
            if (win.ko && win.ko.applyBindings) {
                return { version: win.ko.version || UNKNOWN_VERSION };
            }
            return false;
        }
    },

    'Spine': {
        id: 'spine',
        icon: 'icon38',
        url: 'http://spine.github.io/',
        test: function(win) {
            if (win.Spine && win.Spine.Controller) {
                return {version: win.Spine.version || UNKNOWN_VERSION};
            }
            return false;
        }
    },

    'jQuery Mobile': {
        id: 'jquery-mobile',
        icon: 'jquery_mobile',
        url: 'http://jquerymobile.com/',
        npm: 'jquery-mobile',
        test: function(win) {
            var jq = win.jQuery || win.$ || win.$jq || win.$j;
            if(jq && jq.fn && jq.fn.jquery && jq.mobile) {
                return { version: jq.mobile.version || UNKNOWN_VERSION };
            }
            return false;
        }
    },

    'WebFont Loader': {
        id: 'webfontloader',
        icon: 'icon38',
        url: 'https://github.com/typekit/webfontloader',
        npm: 'webfontloader',
        test: function(win) {
            if(win.WebFont && win.WebFont.load) {
                return { version: UNKNOWN_VERSION };
            }
            return false;
        }
    },

    'Angular': {
        id: 'angular',
        icon: 'angular',
        url: 'https://angular.io/',
        npm: '@angular/core',
        test: function(win) {
            var ngVersion = win.document.querySelector('[ng-version]');
            if (ngVersion) {
                return { version: ngVersion.getAttribute('ng-version') || UNKNOWN_VERSION };
            }
            else if (win.ng && win.ng.probe instanceof Function) {
                return { version: UNKNOWN_VERSION };
            }
            return false;
        }
    },

    'AngularJS': {
        id: 'angularjs',
        icon: 'angularjs',
        url: 'https://angularjs.org/',
        npm: 'angular',
        test: function(win) {
            var ng = win.angular;
            if(ng && ng.version && ng.version.full) {
                return { version: ng.version.full };
            }
            else if (ng) {
                return { version: UNKNOWN_VERSION };
            }
            return false;
        }
    },

    'Ember.js': {
        id: 'emberjs',
        icon: 'emberjs',
        url: 'https://emberjs.com/',
        npm: 'ember-source',
        test: function(win) {
            var ember = win.Ember || win.Em;
            if (ember && ember.GUID_KEY) {
                return { version: ember.VERSION || UNKNOWN_VERSION };
            }
            return false;
        }
    },

    'Ember.js (Fast path)': {
        id: 'emberjs-fast',
        icon: 'emberjs',
        url: 'https://emberjs.com/',
        npm: 'ember-source',
        test: function (win) {
            var ember = win.Ember || win.Em;
            if (ember) {
                return { version: ember.VERSION || UNKNOWN_VERSION };
            }
            return false;
        }
    },

    'Hammer.js': {
        id: 'hammerjs',
        icon: 'hammerjs',
        url: 'http://eightmedia.github.io/hammer.js/',
        npm: 'hammerjs',
        test: function(win) {
            if(win.Hammer && win.Hammer.Pinch) {
                // Hammer.VERSION available in 1.0.10+
                return { version: win.Hammer.VERSION || "&lt; 1.0.10" };
            }
            return false;
        }
    },

    'Visibility.js': {
        id: 'visibilityjs',
        icon: 'icon38',
        url: 'https://github.com/ai/visibilityjs',
        npm: 'visibilityjs',
        test: function(win) {
            if(win.Visibility && win.Visibility.every) {
                return { version: UNKNOWN_VERSION };
            }
            return false;
        }
    },

    'Velocity.js': {
        id: 'velocityjs',
        icon: 'icon38',
        url: 'http://velocityjs.org/',
        npm: 'velocity-animate',
        test: function(win) {
            var jq = win.jQuery || win.$,
                velocity = jq ? jq.Velocity : win.Velocity;

            if(velocity && velocity.RegisterEffect && velocity.version) {
                return {
                    version:
                        velocity.version.major + "." +
                        velocity.version.minor + "." +
                        velocity.version.patch
                };
            }
            else if (velocity && velocity.RegisterEffect) {
                return { version: UNKNOWN_VERSION };
            }
            return false;
        }
    },

    'IfVisible.js': {
        id: 'ifvisiblejs',
        icon: 'icon38',
        url: 'http://serkanyersen.github.io/ifvisible.js/',
        npm: 'ifvisible.js',
        test: function(win) {
            var iv = win.ifvisible;
            if(iv && iv.__ceGUID === "ifvisible.object.event.identifier") {
                return { version: UNKNOWN_VERSION };
            }
            return false;
        }
    },
    'Pixi.js': {
        id: 'pixi',
        icon: 'pixi',
        url: 'http://www.pixijs.com/',
        npm: 'pixi.js',
        test: function(win) {
            var px = win.PIXI;
            if(px && px.WebGLRenderer && px.VERSION) {
                // version 4.4.3 returns simply "4.4.3"; version 1.5.2 returns "v1.5.2"
                return { version: px.VERSION.replace('v', '') || UNKNOWN_VERSION };
            }
            return false;
        }
    },
    'DC.js': {
        id: 'dcjs',
        icon: 'dcjs',
        url: 'http://dc-js.github.io/dc.js/',
        npm: 'dc',
        test: function(win) {
            var dc = win.dc;
            if(dc && dc.registerChart) {
                return { version: dc.version || UNKNOWN_VERSION };
            }
            return false;
        }
    },
    'GreenSock JS': {
        id: 'greensock',
        icon: 'greensock',
        url: 'https://greensock.com/gsap',
        npm: 'gsap',
        test: function(win) {
            if (win.TweenMax && win.TweenMax.pauseAll) {
                return { version: win.TweenMax.version || UNKNOWN_VERSION };
            }
            return false;
        }
    },
    'FastClick': {
        id: 'fastclick',
        icon: 'fastclick',
        url: 'https://github.com/ftlabs/fastclick',
        npm: 'fastclick',
        test: function(win) {
            if(win.FastClick && win.FastClick.notNeeded) {
                return { version: UNKNOWN_VERSION };
            }
            return false;
        }
    },
    'Isotope': {
        id: 'isotope',
        icon: 'isotope',
        url: 'https://isotope.metafizzy.co/',
        npm: 'isotope-layout',
        test: function(win) {
            if(win.Isotope || (win.$ != null && win.$.Isotope)) {
                return { version: UNKNOWN_VERSION };
            }
            return false;
        }
    },
    'Marionette': {
        id: 'marionette',
        icon: 'marionette',
        url: 'https://marionettejs.com/',
        npm: 'backbone.marionette',
        test: function(win) {
            if(win.Marionette && win.Marionette.Application) {
                return { version: win.Marionette.VERSION || UNKNOWN_VERSION };
            }
            return false;
        }
    },
    'Can': {
        id: 'canjs',
        icon: 'canjs',
        url: 'https://canjs.com/',
        npm: 'can',
        test: function (win) {
            if (win.can && win.can.Construct) {
                return { version: win.can.VERSION || UNKNOWN_VERSION };
            }
            return false;
        }
    },
    'Vue': {
        id: 'vue',
        icon: 'vue',
        url: 'https://vuejs.org/',
        npm: 'vue',
        test: function(win) {
            function isVueNode(node) {
                return node.__vue__ != null ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
            }
            var hasVueNode = document.createTreeWalker(document.body, NodeFilter.SHOW_ELEMENT, isVueNode).nextNode() !== null;
            if (hasVueNode) {
                return { version: win.Vue && win.Vue.version || UNKNOWN_VERSION };
            }
            return false;
        }
    },
    'Vue (Fast path)': {
        id: 'vue-fast',
        icon: 'vue',
        url: 'https://vuejs.org/',
        npm: 'vue',
        test: function (win) {
            if (win.Vue) {
                return { version: win.Vue && win.Vue.version || UNKNOWN_VERSION };
            }
            return false;
        }
    },
    'Nuxt.js': {
        id: 'nuxt',
        icon: 'nuxt',
        url: 'https://nuxtjs.org/',
        npm: 'nuxt',
        test: function(win) {
            if ((win.__NUXT__ && win.__NUXT__.data != null) || win.$nuxt) {
                return { version: UNKNOWN_VERSION };
            }
            return false;
        }
    },
    'Nuxt.js (Fast path)': {
        id: 'nuxt-fast',
        icon: 'nuxt',
        url: 'https://nuxtjs.org/',
        npm: 'nuxt',
        test: function (win) {
            if (win.__NUXT__  || win.$nuxt) {
                return { version: UNKNOWN_VERSION };
            }
            return false;
        }
    },
    'Two': {
        id: 'two',
        icon: 'two',
        url: 'https://two.js.org/',
        npm: 'two.js',
        test: function(win) {
            if (win.Two && win.Two.Utils) {
                return { version: win.Two.Version || UNKNOWN_VERSION };
            }
            return false;
        }
    },
    'Brewser': {
        id: 'brewser',
        icon: 'brewser',
        url: 'https://robertpataki.github.io/brewser/',
        npm: 'brewser',
        test: function(win) {
            if(win.BREWSER && win.BREWSER.ua) {
                return { version: BREWSER.VERSION || UNKNOWN_VERSION };
            }
            return false;
        }
    },
    'Material Design Lite': {
        id: 'materialdesignlite',
        icon: 'mdl',
        url: 'https://getmdl.io/',
        npm: 'material-design-lite',
        test: function(win) {
            if(win.componentHandler && win.componentHandler.upgradeElement) {
                return { version: UNKNOWN_VERSION};
            }
            return false;
        }
    },
    'Kendo UI': {
        id: 'kendoui',
        icon: 'kendoui',
        url: 'https://github.com/telerik/kendo-ui-core',
        npm: 'kendo-ui-core',
        test: function(win) {
            if (win.kendo && win.kendo.View && win.kendo.View.extend) {
                return {version: win.kendo.version || UNKNOWN_VERSION};
            }
            return false;
        }
    },
    'Matter.js': {
        id: 'matterjs',
        icon: 'matter-js',
        url: 'http://brm.io/matter-js/',
        npm: 'matter-js',
        test: function(win) {
            if (win.Matter && win.Matter.Engine) {
                return {version: UNKNOWN_VERSION};
            }
            return false;
        }
    },
    'Riot': {
        id: 'riot',
        icon: 'riot',
        url: 'http://riotjs.com/',
        npm: 'riot',
        test: function(win) {
            if (win.riot && win.riot.mixin) {
                return { version: win.riot.version || UNKNOWN_VERSION };
            }
            return false;
        }
    },
    'Sea.js': {
        id: 'seajs',
        icon: 'icon38',
        url: 'https://seajs.github.io/seajs/docs/',
        npm: 'seajs',
        test: function(win) {
            if(win.seajs && win.seajs.use) {
                return { version: win.seajs.version || UNKNOWN_VERSION };
            }
            return false;
        }
    },
    'Moment.js': {
        id: 'momentjs',
        icon: 'momentjs',
        url: 'http://momentjs.com/',
        npm: 'moment',
        test: function(win) {
            if(win.moment && (win.moment.isMoment || win.moment.lang)) {
                // version 1.0.0 has neither "isMoment" nor "version"
                return { version: win.moment.version || UNKNOWN_VERSION };
            }
            return false;
        }
    },
    'Moment Timezone': {
        id: 'moment-timezone',
        icon: 'momentjs',
        url: 'http://momentjs.com/timezone/',
        npm: 'moment-timezone',
        test: function(win) {
            if (win.moment && win.moment.tz) {
                return { version: win.moment.tz.version || UNKNOWN_VERSION };
            }
            return false;
        }
    },
    'ScrollMagic': {
        id: 'scrollmagic',
        icon: 'scrollmagic',
        url: 'http://scrollmagic.io/',
        npm: 'scrollmagic',
        test: function(win) {
            if (win.ScrollMagic && win.ScrollMagic.Controller) {
                return {version: ScrollMagic.version || UNKNOWN_VERSION};
            }
            return false;
        }
    },
    'SWFObject': {
        id: 'swfobject',
        icon: 'icon38', // currently has no icon
        url: 'https://github.com/swfobject/swfobject',
        test: function(win) {
            if (win.swfobject && win.swfobject.embedSWF) {
                // 2.x - exact version only for 2.3
                return { version: win.swfobject.version || UNKNOWN_VERSION };
            } else if(win.deconcept && win.deconcept.SWFObject) {
                // 1.x
                return { version: UNKNOWN_VERSION };
            }
            return false;
        }
    },
    'FlexSlider': {
        id: 'flexslider',
        icon: 'icon38', // currently has no icon
        url: 'https://woocommerce.com/flexslider/',
        npm: 'flexslider',
        test: function(win) {
            var jq = win.jQuery || win.$ || win.$jq || win.$j;
            if (jq && jq.fn && jq.fn.jquery && jq.flexslider){
                return { version: UNKNOWN_VERSION };
            }
            return false;
        }
    },
    'SPF': {
        id: 'spf',
        icon: 'icon38', // currently has no icon
        url: 'https://youtube.github.io/spfjs/',
        npm: 'spf',
        test: function(win) {
            if (win.spf && win.spf.init) {
                return { version: UNKNOWN_VERSION };
            }
            return false;
        }
    },
    'Numeral.js': {
        id: 'numeraljs',
        icon: 'icon38', // currently has no icon
        url: 'http://numeraljs.com/',
        npm: 'numeraljs',
        test: function(win) {
            if (win.numeral && win.isNumeral) {
                return { version: win.numeral.version || UNKNOWN_VERSION };
            }
            return false;
        }
    },
    'boomerang.js': {
        id: 'boomerangjs',
        icon: 'icon38', // currently has no icon
        url: 'https://soasta.github.io/boomerang/',
        npm: 'boomerangjs',
        test: function(win) {
            if (win.BOOMR && win.BOOMR.utils && win.BOOMR.init) {
                return { version: win.BOOMR.version || UNKNOWN_VERSION };
            }
            return false;
        }
    },
    'Framer': {
        id: 'framer',
        icon: 'framer',
        url: 'https://framer.com/',
        npm: 'framerjs',
        test: function(win) {
            if (win.Framer && win.Framer.Layer) {
                return { version: win.Framer.Version.build || UNKNOWN_VERSION };
            }
            return false;
        }
    },
    'Marko': {
        id: 'marko',
        icon: 'marko',
        url: 'https://markojs.com/',
        npm: 'marko',
        test: function (win) {
            var selector = '[data-marko-key], [data-marko]';
            var markoElement = document.querySelector(selector);
            if (markoElement) {
                return { version: UNKNOWN_VERSION };
            }
            return false;
        }
    },
    'AMP': {
        id: 'amp',
        icon: 'amp',
        url: 'https://amp.dev/',
        npm: 'https://www.npmjs.com/org/ampproject',
        test: function (win) {
            var version = win.document.documentElement.getAttribute("amp-version");
            return version ? { version: version } : false;
        }
    },
    'Gatsby': {
        id: 'gatsby',
        icon: 'gatsby',
        url: 'https://www.gatsbyjs.org/',
        npm: 'gatsby',
        test: function (win) {
            if (document.getElementById('___gatsby')) {
                return { version: UNKNOWN_VERSION };
            }
            return false;
        }
    },
    'Shopify': {
        id: 'shopify',
        icon: 'shopify',
        url: 'https://www.shopify.com/',
        npm: null,
        test: function (win) {
            if (win.Shopify && win.Shopify.shop) {
                return { version: UNKNOWN_VERSION };
            }
            return false;
        }
    },
    'Magento': {
        id: 'magento',
        icon: 'magento',
        url: 'https://magento.com/',
        npm: null,
        test: function (win) {
            // Same detecton used in Magento 2 DevTools: https://github.com/magento/m2-devtools
            const reRequireScript = /\/static(?:\/version\d+)?\/frontend\/.+\/.+\/requirejs\/require(?:\.min)?\.js/;
            const scripts = Array.from(document.querySelectorAll('script[src]') || []);
            if (scripts.some(s => reRequireScript.test(s.src))) {
                return { version: 2 }; // Magento 1 is no longer supported and this only verifies version 2
            }
            
            return false;
        }
    },
    'WordPress': {
        id: 'wordpress',
        icon: 'wordpress',
        url: 'https://wordpress.org/',
        npm: null,
        test: function (win) {
            const hasAPILinkElem = !!document.querySelector('link[rel="https://api.w.org/"]');
            const hasWPIncludes = !!document.querySelectorAll('link[href*="wp-includes"], script[src*="wp-includes"]').length;

            if (!hasAPILinkElem && !hasWPIncludes) return false;

            const generatorMeta = document.querySelector('meta[name=generator][content^="WordPress"]');
            const version = generatorMeta ? generatorMeta.getAttribute("content").replace(/^\w+\s/,'') : UNKNOWN_VERSION;
            return { version };
        }
    },
    'Wix': {
        id: 'wix',
        icon: 'wix',
        url: 'https://www.wix.com/',
        npm: null,
        test: function (win) {
            if (win.wixBiSession) {
                return { version: UNKNOWN_VERSION };
            }
            return false;
        }
    },
    'Workbox': {
      id: 'workbox',
      icon: 'workbox',
      url: 'https://developers.google.com/web/tools/workbox/',
      npm: 'workbox-sw',
      test: async function (win) {
        var nav = win.navigator;
        // Service Workers not supported
        if (!('serviceWorker' in nav)) {
          return false;
        }
        return nav.serviceWorker.getRegistration()
        .then(function(registration) {
          var scriptURL = nav.serviceWorker.controller.scriptURL;
          return fetch(scriptURL, { credentials: 'include',
            headers: { 'service-worker': 'script' }
          })
          .then(function(response) {
            return response.text();
          })
          .then(function(scriptContent) {
            var workboxRegExp = /new Workbox|new workbox|workbox\.precaching\.|workbox\.strategies/gm;
            if (workboxRegExp.test(scriptContent)) {
              // Adapted from
              // https://github.com/semver/semver/issues/232#issue-48635632
              var semVerRegExp = /workbox.*?\b((0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)(-(0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(\.(0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*)?(\+[0-9a-zA-Z-]+(\.[0-9a-zA-Z-]+)*)?)\b/gim;
              var matches = semVerRegExp.exec(scriptContent);
              var version = UNKNOWN_VERSION;
              if (Array.isArray(matches) && matches.length > 1 && matches[1]) {
                version = matches[1];
              }
              return { version: version };
            }
            return false;
          });
        }).catch(function(exception) {
          return false;
        });
      }
    },
    'Boq': {
        id: 'boq',
        icon: 'icon38',
        url: 'https://github.com/johnmichel/Library-Detector-for-Chrome/pull/143',
        npm: null,
        test: function (win) {
            if (win.WIZ_global_data) {
                return { version: UNKNOWN_VERSION };
            }
            return false;
        }
    },
    'Wiz': {
        id: 'wiz',
        icon: 'icon38',
        url: 'https://github.com/johnmichel/Library-Detector-for-Chrome/pull/147',
        npm: null,
        test: function (win) {
            if (document.__wizdispatcher) {
                return { version: UNKNOWN_VERSION };
            }
            return false;
        }
    },
    'core-js': {
        id: 'corejs',
        icon: 'icon38',
        url: 'https://github.com/zloirock/core-js',
        npm: 'core-js',
        test: function (win) {
            const shared = win['__core-js_shared__'];
            const core = win.core;
            if (shared) {
                const versions = shared.versions;
                return { version: Array.isArray(versions) ? versions.map(it => `core-js-${ it.mode }@${ it.version }`).join('; ') : UNKNOWN_VERSION };
            } else if (core) {
                return { version: core.version || UNKNOWN_VERSION };
            }
            return false;
        }
    },
    'Drupal': {
        id: 'drupal',
        icon: 'drupal',
        url: 'https://www.drupal.org/',
        npm: null,
        test: function (win) {
            const generatorMeta = document.querySelector('meta[name=Generator][content^="Drupal"]');
            const version = generatorMeta ? generatorMeta.getAttribute("content").replace(/\D+/gi,'') : UNKNOWN_VERSION;

            // Detect Drupal resources patterns
            const resDrupal = /\/sites\/(?:default|all)\/(?:themes|modules|files)/;
            const res = Array.from(document.querySelectorAll('link,style,script') || []);

            if (res.some(s => resDrupal.test(s.src)) || res.some(s => resDrupal.test(s.href)) ||
                generatorMeta || (win.Drupal && win.Drupal.behaviors)) {
                return { version };
            }

            return false;
        }
    }
};

var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

function commonjsRequire () {
	throw new Error('Dynamic requires are not currently supported by @rollup/plugin-commonjs');
}

function unwrapExports (x) {
	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}

function createCommonjsModule(fn, module) {
	return module = { exports: {} }, fn(module, module.exports), module.exports;
}

function getCjsExportFromNamespace (n) {
	return n && n['default'] || n;
}

// Note: this is the semver.org version of the spec that it implements
// Not necessarily the package version of this code.
const SEMVER_SPEC_VERSION = '2.0.0';

const MAX_LENGTH = 256;
const MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER ||
  /* istanbul ignore next */ 9007199254740991;

// Max safe segment length for coercion.
const MAX_SAFE_COMPONENT_LENGTH = 16;

var constants = {
  SEMVER_SPEC_VERSION,
  MAX_LENGTH,
  MAX_SAFE_INTEGER,
  MAX_SAFE_COMPONENT_LENGTH
};
var constants_1 = constants.SEMVER_SPEC_VERSION;
var constants_2 = constants.MAX_LENGTH;
var constants_3 = constants.MAX_SAFE_INTEGER;
var constants_4 = constants.MAX_SAFE_COMPONENT_LENGTH;

const debug = (
  typeof process === 'object' &&
  process.env &&
  process.env.NODE_DEBUG &&
  /\bsemver\b/i.test(process.env.NODE_DEBUG)
) ? (...args) => console.error('SEMVER', ...args)
  : () => {};

var debug_1 = debug;

var re_1 = createCommonjsModule(function (module, exports) {
const { MAX_SAFE_COMPONENT_LENGTH } = constants;

exports = module.exports = {};

// The actual regexps go on exports.re
const re = exports.re = [];
const src = exports.src = [];
const t = exports.t = {};
let R = 0;

const createToken = (name, value, isGlobal) => {
  const index = R++;
  debug_1(index, value);
  t[name] = index;
  src[index] = value;
  re[index] = new RegExp(value, isGlobal ? 'g' : undefined);
};

// The following Regular Expressions can be used for tokenizing,
// validating, and parsing SemVer version strings.

// ## Numeric Identifier
// A single `0`, or a non-zero digit followed by zero or more digits.

createToken('NUMERICIDENTIFIER', '0|[1-9]\\d*');
createToken('NUMERICIDENTIFIERLOOSE', '[0-9]+');

// ## Non-numeric Identifier
// Zero or more digits, followed by a letter or hyphen, and then zero or
// more letters, digits, or hyphens.

createToken('NONNUMERICIDENTIFIER', '\\d*[a-zA-Z-][a-zA-Z0-9-]*');

// ## Main Version
// Three dot-separated numeric identifiers.

createToken('MAINVERSION', `(${src[t.NUMERICIDENTIFIER]})\\.` +
                   `(${src[t.NUMERICIDENTIFIER]})\\.` +
                   `(${src[t.NUMERICIDENTIFIER]})`);

createToken('MAINVERSIONLOOSE', `(${src[t.NUMERICIDENTIFIERLOOSE]})\\.` +
                        `(${src[t.NUMERICIDENTIFIERLOOSE]})\\.` +
                        `(${src[t.NUMERICIDENTIFIERLOOSE]})`);

// ## Pre-release Version Identifier
// A numeric identifier, or a non-numeric identifier.

createToken('PRERELEASEIDENTIFIER', `(?:${src[t.NUMERICIDENTIFIER]
}|${src[t.NONNUMERICIDENTIFIER]})`);

createToken('PRERELEASEIDENTIFIERLOOSE', `(?:${src[t.NUMERICIDENTIFIERLOOSE]
}|${src[t.NONNUMERICIDENTIFIER]})`);

// ## Pre-release Version
// Hyphen, followed by one or more dot-separated pre-release version
// identifiers.

createToken('PRERELEASE', `(?:-(${src[t.PRERELEASEIDENTIFIER]
}(?:\\.${src[t.PRERELEASEIDENTIFIER]})*))`);

createToken('PRERELEASELOOSE', `(?:-?(${src[t.PRERELEASEIDENTIFIERLOOSE]
}(?:\\.${src[t.PRERELEASEIDENTIFIERLOOSE]})*))`);

// ## Build Metadata Identifier
// Any combination of digits, letters, or hyphens.

createToken('BUILDIDENTIFIER', '[0-9A-Za-z-]+');

// ## Build Metadata
// Plus sign, followed by one or more period-separated build metadata
// identifiers.

createToken('BUILD', `(?:\\+(${src[t.BUILDIDENTIFIER]
}(?:\\.${src[t.BUILDIDENTIFIER]})*))`);

// ## Full Version String
// A main version, followed optionally by a pre-release version and
// build metadata.

// Note that the only major, minor, patch, and pre-release sections of
// the version string are capturing groups.  The build metadata is not a
// capturing group, because it should not ever be used in version
// comparison.

createToken('FULLPLAIN', `v?${src[t.MAINVERSION]
}${src[t.PRERELEASE]}?${
  src[t.BUILD]}?`);

createToken('FULL', `^${src[t.FULLPLAIN]}$`);

// like full, but allows v1.2.3 and =1.2.3, which people do sometimes.
// also, 1.0.0alpha1 (prerelease without the hyphen) which is pretty
// common in the npm registry.
createToken('LOOSEPLAIN', `[v=\\s]*${src[t.MAINVERSIONLOOSE]
}${src[t.PRERELEASELOOSE]}?${
  src[t.BUILD]}?`);

createToken('LOOSE', `^${src[t.LOOSEPLAIN]}$`);

createToken('GTLT', '((?:<|>)?=?)');

// Something like "2.*" or "1.2.x".
// Note that "x.x" is a valid xRange identifer, meaning "any version"
// Only the first item is strictly required.
createToken('XRANGEIDENTIFIERLOOSE', `${src[t.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`);
createToken('XRANGEIDENTIFIER', `${src[t.NUMERICIDENTIFIER]}|x|X|\\*`);

createToken('XRANGEPLAIN', `[v=\\s]*(${src[t.XRANGEIDENTIFIER]})` +
                   `(?:\\.(${src[t.XRANGEIDENTIFIER]})` +
                   `(?:\\.(${src[t.XRANGEIDENTIFIER]})` +
                   `(?:${src[t.PRERELEASE]})?${
                     src[t.BUILD]}?` +
                   `)?)?`);

createToken('XRANGEPLAINLOOSE', `[v=\\s]*(${src[t.XRANGEIDENTIFIERLOOSE]})` +
                        `(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})` +
                        `(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})` +
                        `(?:${src[t.PRERELEASELOOSE]})?${
                          src[t.BUILD]}?` +
                        `)?)?`);

createToken('XRANGE', `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAIN]}$`);
createToken('XRANGELOOSE', `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAINLOOSE]}$`);

// Coercion.
// Extract anything that could conceivably be a part of a valid semver
createToken('COERCE', `${'(^|[^\\d])' +
              '(\\d{1,'}${MAX_SAFE_COMPONENT_LENGTH}})` +
              `(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?` +
              `(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?` +
              `(?:$|[^\\d])`);
createToken('COERCERTL', src[t.COERCE], true);

// Tilde ranges.
// Meaning is "reasonably at or greater than"
createToken('LONETILDE', '(?:~>?)');

createToken('TILDETRIM', `(\\s*)${src[t.LONETILDE]}\\s+`, true);
exports.tildeTrimReplace = '$1~';

createToken('TILDE', `^${src[t.LONETILDE]}${src[t.XRANGEPLAIN]}$`);
createToken('TILDELOOSE', `^${src[t.LONETILDE]}${src[t.XRANGEPLAINLOOSE]}$`);

// Caret ranges.
// Meaning is "at least and backwards compatible with"
createToken('LONECARET', '(?:\\^)');

createToken('CARETTRIM', `(\\s*)${src[t.LONECARET]}\\s+`, true);
exports.caretTrimReplace = '$1^';

createToken('CARET', `^${src[t.LONECARET]}${src[t.XRANGEPLAIN]}$`);
createToken('CARETLOOSE', `^${src[t.LONECARET]}${src[t.XRANGEPLAINLOOSE]}$`);

// A simple gt/lt/eq thing, or just "" to indicate "any version"
createToken('COMPARATORLOOSE', `^${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]})$|^$`);
createToken('COMPARATOR', `^${src[t.GTLT]}\\s*(${src[t.FULLPLAIN]})$|^$`);

// An expression to strip any whitespace between the gtlt and the thing
// it modifies, so that `> 1.2.3` ==> `>1.2.3`
createToken('COMPARATORTRIM', `(\\s*)${src[t.GTLT]
}\\s*(${src[t.LOOSEPLAIN]}|${src[t.XRANGEPLAIN]})`, true);
exports.comparatorTrimReplace = '$1$2$3';

// Something like `1.2.3 - 1.2.4`
// Note that these all use the loose form, because they'll be
// checked against either the strict or loose comparator form
// later.
createToken('HYPHENRANGE', `^\\s*(${src[t.XRANGEPLAIN]})` +
                   `\\s+-\\s+` +
                   `(${src[t.XRANGEPLAIN]})` +
                   `\\s*$`);

createToken('HYPHENRANGELOOSE', `^\\s*(${src[t.XRANGEPLAINLOOSE]})` +
                        `\\s+-\\s+` +
                        `(${src[t.XRANGEPLAINLOOSE]})` +
                        `\\s*$`);

// Star ranges basically just allow anything at all.
createToken('STAR', '(<|>)?=?\\s*\\*');
});
var re_2 = re_1.re;
var re_3 = re_1.src;
var re_4 = re_1.t;
var re_5 = re_1.tildeTrimReplace;
var re_6 = re_1.caretTrimReplace;
var re_7 = re_1.comparatorTrimReplace;

const numeric = /^[0-9]+$/;
const compareIdentifiers = (a, b) => {
  const anum = numeric.test(a);
  const bnum = numeric.test(b);

  if (anum && bnum) {
    a = +a;
    b = +b;
  }

  return a === b ? 0
    : (anum && !bnum) ? -1
    : (bnum && !anum) ? 1
    : a < b ? -1
    : 1
};

const rcompareIdentifiers = (a, b) => compareIdentifiers(b, a);

var identifiers = {
  compareIdentifiers,
  rcompareIdentifiers
};
var identifiers_1 = identifiers.compareIdentifiers;
var identifiers_2 = identifiers.rcompareIdentifiers;

const { MAX_LENGTH: MAX_LENGTH$1, MAX_SAFE_INTEGER: MAX_SAFE_INTEGER$1 } = constants;
const { re, t } = re_1;

const { compareIdentifiers: compareIdentifiers$1 } = identifiers;
class SemVer {
  constructor (version, options) {
    if (!options || typeof options !== 'object') {
      options = {
        loose: !!options,
        includePrerelease: false
      };
    }
    if (version instanceof SemVer) {
      if (version.loose === !!options.loose &&
          version.includePrerelease === !!options.includePrerelease) {
        return version
      } else {
        version = version.version;
      }
    } else if (typeof version !== 'string') {
      throw new TypeError(`Invalid Version: ${version}`)
    }

    if (version.length > MAX_LENGTH$1) {
      throw new TypeError(
        `version is longer than ${MAX_LENGTH$1} characters`
      )
    }

    debug_1('SemVer', version, options);
    this.options = options;
    this.loose = !!options.loose;
    // this isn't actually relevant for versions, but keep it so that we
    // don't run into trouble passing this.options around.
    this.includePrerelease = !!options.includePrerelease;

    const m = version.trim().match(options.loose ? re[t.LOOSE] : re[t.FULL]);

    if (!m) {
      throw new TypeError(`Invalid Version: ${version}`)
    }

    this.raw = version;

    // these are actually numbers
    this.major = +m[1];
    this.minor = +m[2];
    this.patch = +m[3];

    if (this.major > MAX_SAFE_INTEGER$1 || this.major < 0) {
      throw new TypeError('Invalid major version')
    }

    if (this.minor > MAX_SAFE_INTEGER$1 || this.minor < 0) {
      throw new TypeError('Invalid minor version')
    }

    if (this.patch > MAX_SAFE_INTEGER$1 || this.patch < 0) {
      throw new TypeError('Invalid patch version')
    }

    // numberify any prerelease numeric ids
    if (!m[4]) {
      this.prerelease = [];
    } else {
      this.prerelease = m[4].split('.').map((id) => {
        if (/^[0-9]+$/.test(id)) {
          const num = +id;
          if (num >= 0 && num < MAX_SAFE_INTEGER$1) {
            return num
          }
        }
        return id
      });
    }

    this.build = m[5] ? m[5].split('.') : [];
    this.format();
  }

  format () {
    this.version = `${this.major}.${this.minor}.${this.patch}`;
    if (this.prerelease.length) {
      this.version += `-${this.prerelease.join('.')}`;
    }
    return this.version
  }

  toString () {
    return this.version
  }

  compare (other) {
    debug_1('SemVer.compare', this.version, this.options, other);
    if (!(other instanceof SemVer)) {
      if (typeof other === 'string' && other === this.version) {
        return 0
      }
      other = new SemVer(other, this.options);
    }

    if (other.version === this.version) {
      return 0
    }

    return this.compareMain(other) || this.comparePre(other)
  }

  compareMain (other) {
    if (!(other instanceof SemVer)) {
      other = new SemVer(other, this.options);
    }

    return (
      compareIdentifiers$1(this.major, other.major) ||
      compareIdentifiers$1(this.minor, other.minor) ||
      compareIdentifiers$1(this.patch, other.patch)
    )
  }

  comparePre (other) {
    if (!(other instanceof SemVer)) {
      other = new SemVer(other, this.options);
    }

    // NOT having a prerelease is > having one
    if (this.prerelease.length && !other.prerelease.length) {
      return -1
    } else if (!this.prerelease.length && other.prerelease.length) {
      return 1
    } else if (!this.prerelease.length && !other.prerelease.length) {
      return 0
    }

    let i = 0;
    do {
      const a = this.prerelease[i];
      const b = other.prerelease[i];
      debug_1('prerelease compare', i, a, b);
      if (a === undefined && b === undefined) {
        return 0
      } else if (b === undefined) {
        return 1
      } else if (a === undefined) {
        return -1
      } else if (a === b) {
        continue
      } else {
        return compareIdentifiers$1(a, b)
      }
    } while (++i)
  }

  compareBuild (other) {
    if (!(other instanceof SemVer)) {
      other = new SemVer(other, this.options);
    }

    let i = 0;
    do {
      const a = this.build[i];
      const b = other.build[i];
      debug_1('prerelease compare', i, a, b);
      if (a === undefined && b === undefined) {
        return 0
      } else if (b === undefined) {
        return 1
      } else if (a === undefined) {
        return -1
      } else if (a === b) {
        continue
      } else {
        return compareIdentifiers$1(a, b)
      }
    } while (++i)
  }

  // preminor will bump the version up to the next minor release, and immediately
  // down to pre-release. premajor and prepatch work the same way.
  inc (release, identifier) {
    switch (release) {
      case 'premajor':
        this.prerelease.length = 0;
        this.patch = 0;
        this.minor = 0;
        this.major++;
        this.inc('pre', identifier);
        break
      case 'preminor':
        this.prerelease.length = 0;
        this.patch = 0;
        this.minor++;
        this.inc('pre', identifier);
        break
      case 'prepatch':
        // If this is already a prerelease, it will bump to the next version
        // drop any prereleases that might already exist, since they are not
        // relevant at this point.
        this.prerelease.length = 0;
        this.inc('patch', identifier);
        this.inc('pre', identifier);
        break
      // If the input is a non-prerelease version, this acts the same as
      // prepatch.
      case 'prerelease':
        if (this.prerelease.length === 0) {
          this.inc('patch', identifier);
        }
        this.inc('pre', identifier);
        break

      case 'major':
        // If this is a pre-major version, bump up to the same major version.
        // Otherwise increment major.
        // 1.0.0-5 bumps to 1.0.0
        // 1.1.0 bumps to 2.0.0
        if (
          this.minor !== 0 ||
          this.patch !== 0 ||
          this.prerelease.length === 0
        ) {
          this.major++;
        }
        this.minor = 0;
        this.patch = 0;
        this.prerelease = [];
        break
      case 'minor':
        // If this is a pre-minor version, bump up to the same minor version.
        // Otherwise increment minor.
        // 1.2.0-5 bumps to 1.2.0
        // 1.2.1 bumps to 1.3.0
        if (this.patch !== 0 || this.prerelease.length === 0) {
          this.minor++;
        }
        this.patch = 0;
        this.prerelease = [];
        break
      case 'patch':
        // If this is not a pre-release version, it will increment the patch.
        // If it is a pre-release it will bump up to the same patch version.
        // 1.2.0-5 patches to 1.2.0
        // 1.2.0 patches to 1.2.1
        if (this.prerelease.length === 0) {
          this.patch++;
        }
        this.prerelease = [];
        break
      // This probably shouldn't be used publicly.
      // 1.0.0 'pre' would become 1.0.0-0 which is the wrong direction.
      case 'pre':
        if (this.prerelease.length === 0) {
          this.prerelease = [0];
        } else {
          let i = this.prerelease.length;
          while (--i >= 0) {
            if (typeof this.prerelease[i] === 'number') {
              this.prerelease[i]++;
              i = -2;
            }
          }
          if (i === -1) {
            // didn't increment anything
            this.prerelease.push(0);
          }
        }
        if (identifier) {
          // 1.2.0-beta.1 bumps to 1.2.0-beta.2,
          // 1.2.0-beta.fooblz or 1.2.0-beta bumps to 1.2.0-beta.0
          if (this.prerelease[0] === identifier) {
            if (isNaN(this.prerelease[1])) {
              this.prerelease = [identifier, 0];
            }
          } else {
            this.prerelease = [identifier, 0];
          }
        }
        break

      default:
        throw new Error(`invalid increment argument: ${release}`)
    }
    this.format();
    this.raw = this.version;
    return this
  }
}

var semver = SemVer;

const {MAX_LENGTH: MAX_LENGTH$2} = constants;
const { re: re$1, t: t$1 } = re_1;


const parse = (version, options) => {
  if (!options || typeof options !== 'object') {
    options = {
      loose: !!options,
      includePrerelease: false
    };
  }

  if (version instanceof semver) {
    return version
  }

  if (typeof version !== 'string') {
    return null
  }

  if (version.length > MAX_LENGTH$2) {
    return null
  }

  const r = options.loose ? re$1[t$1.LOOSE] : re$1[t$1.FULL];
  if (!r.test(version)) {
    return null
  }

  try {
    return new semver(version, options)
  } catch (er) {
    return null
  }
};

var parse_1 = parse;

const valid = (version, options) => {
  const v = parse_1(version, options);
  return v ? v.version : null
};
var valid_1 = valid;

const clean = (version, options) => {
  const s = parse_1(version.trim().replace(/^[=v]+/, ''), options);
  return s ? s.version : null
};
var clean_1 = clean;

const inc = (version, release, options, identifier) => {
  if (typeof (options) === 'string') {
    identifier = options;
    options = undefined;
  }

  try {
    return new semver(version, options).inc(release, identifier).version
  } catch (er) {
    return null
  }
};
var inc_1 = inc;

const compare = (a, b, loose) =>
  new semver(a, loose).compare(new semver(b, loose));

var compare_1 = compare;

const eq = (a, b, loose) => compare_1(a, b, loose) === 0;
var eq_1 = eq;

const diff = (version1, version2) => {
  if (eq_1(version1, version2)) {
    return null
  } else {
    const v1 = parse_1(version1);
    const v2 = parse_1(version2);
    const hasPre = v1.prerelease.length || v2.prerelease.length;
    const prefix = hasPre ? 'pre' : '';
    const defaultResult = hasPre ? 'prerelease' : '';
    for (const key in v1) {
      if (key === 'major' || key === 'minor' || key === 'patch') {
        if (v1[key] !== v2[key]) {
          return prefix + key
        }
      }
    }
    return defaultResult // may be undefined
  }
};
var diff_1 = diff;

const major = (a, loose) => new semver(a, loose).major;
var major_1 = major;

const minor = (a, loose) => new semver(a, loose).minor;
var minor_1 = minor;

const patch = (a, loose) => new semver(a, loose).patch;
var patch_1 = patch;

const prerelease = (version, options) => {
  const parsed = parse_1(version, options);
  return (parsed && parsed.prerelease.length) ? parsed.prerelease : null
};
var prerelease_1 = prerelease;

const rcompare = (a, b, loose) => compare_1(b, a, loose);
var rcompare_1 = rcompare;

const compareLoose = (a, b) => compare_1(a, b, true);
var compareLoose_1 = compareLoose;

const compareBuild = (a, b, loose) => {
  const versionA = new semver(a, loose);
  const versionB = new semver(b, loose);
  return versionA.compare(versionB) || versionA.compareBuild(versionB)
};
var compareBuild_1 = compareBuild;

const sort = (list, loose) => list.sort((a, b) => compareBuild_1(a, b, loose));
var sort_1 = sort;

const rsort = (list, loose) => list.sort((a, b) => compareBuild_1(b, a, loose));
var rsort_1 = rsort;

const gt = (a, b, loose) => compare_1(a, b, loose) > 0;
var gt_1 = gt;

const lt = (a, b, loose) => compare_1(a, b, loose) < 0;
var lt_1 = lt;

const neq = (a, b, loose) => compare_1(a, b, loose) !== 0;
var neq_1 = neq;

const gte = (a, b, loose) => compare_1(a, b, loose) >= 0;
var gte_1 = gte;

const lte = (a, b, loose) => compare_1(a, b, loose) <= 0;
var lte_1 = lte;

const cmp = (a, op, b, loose) => {
  switch (op) {
    case '===':
      if (typeof a === 'object')
        a = a.version;
      if (typeof b === 'object')
        b = b.version;
      return a === b

    case '!==':
      if (typeof a === 'object')
        a = a.version;
      if (typeof b === 'object')
        b = b.version;
      return a !== b

    case '':
    case '=':
    case '==':
      return eq_1(a, b, loose)

    case '!=':
      return neq_1(a, b, loose)

    case '>':
      return gt_1(a, b, loose)

    case '>=':
      return gte_1(a, b, loose)

    case '<':
      return lt_1(a, b, loose)

    case '<=':
      return lte_1(a, b, loose)

    default:
      throw new TypeError(`Invalid operator: ${op}`)
  }
};
var cmp_1 = cmp;

const {re: re$2, t: t$2} = re_1;

const coerce = (version, options) => {
  if (version instanceof semver) {
    return version
  }

  if (typeof version === 'number') {
    version = String(version);
  }

  if (typeof version !== 'string') {
    return null
  }

  options = options || {};

  let match = null;
  if (!options.rtl) {
    match = version.match(re$2[t$2.COERCE]);
  } else {
    // Find the right-most coercible string that does not share
    // a terminus with a more left-ward coercible string.
    // Eg, '1.2.3.4' wants to coerce '2.3.4', not '3.4' or '4'
    //
    // Walk through the string checking with a /g regexp
    // Manually set the index so as to pick up overlapping matches.
    // Stop when we get a match that ends at the string end, since no
    // coercible string can be more right-ward without the same terminus.
    let next;
    while ((next = re$2[t$2.COERCERTL].exec(version)) &&
        (!match || match.index + match[0].length !== version.length)
    ) {
      if (!match ||
            next.index + next[0].length !== match.index + match[0].length) {
        match = next;
      }
      re$2[t$2.COERCERTL].lastIndex = next.index + next[1].length + next[2].length;
    }
    // leave it in a clean state
    re$2[t$2.COERCERTL].lastIndex = -1;
  }

  if (match === null)
    return null

  return parse_1(`${match[2]}.${match[3] || '0'}.${match[4] || '0'}`, options)
};
var coerce_1 = coerce;

// hoisted class for cyclic dependency
class Range {
  constructor (range, options) {
    if (!options || typeof options !== 'object') {
      options = {
        loose: !!options,
        includePrerelease: false
      };
    }

    if (range instanceof Range) {
      if (
        range.loose === !!options.loose &&
        range.includePrerelease === !!options.includePrerelease
      ) {
        return range
      } else {
        return new Range(range.raw, options)
      }
    }

    if (range instanceof comparator) {
      // just put it in the set and return
      this.raw = range.value;
      this.set = [[range]];
      this.format();
      return this
    }

    this.options = options;
    this.loose = !!options.loose;
    this.includePrerelease = !!options.includePrerelease;

    // First, split based on boolean or ||
    this.raw = range;
    this.set = range
      .split(/\s*\|\|\s*/)
      // map the range to a 2d array of comparators
      .map(range => this.parseRange(range.trim()))
      // throw out any comparator lists that are empty
      // this generally means that it was not a valid range, which is allowed
      // in loose mode, but will still throw if the WHOLE range is invalid.
      .filter(c => c.length);

    if (!this.set.length) {
      throw new TypeError(`Invalid SemVer Range: ${range}`)
    }

    this.format();
  }

  format () {
    this.range = this.set
      .map((comps) => {
        return comps.join(' ').trim()
      })
      .join('||')
      .trim();
    return this.range
  }

  toString () {
    return this.range
  }

  parseRange (range) {
    const loose = this.options.loose;
    range = range.trim();
    // `1.2.3 - 1.2.4` => `>=1.2.3 <=1.2.4`
    const hr = loose ? re$3[t$3.HYPHENRANGELOOSE] : re$3[t$3.HYPHENRANGE];
    range = range.replace(hr, hyphenReplace);
    debug_1('hyphen replace', range);
    // `> 1.2.3 < 1.2.5` => `>1.2.3 <1.2.5`
    range = range.replace(re$3[t$3.COMPARATORTRIM], comparatorTrimReplace);
    debug_1('comparator trim', range, re$3[t$3.COMPARATORTRIM]);

    // `~ 1.2.3` => `~1.2.3`
    range = range.replace(re$3[t$3.TILDETRIM], tildeTrimReplace);

    // `^ 1.2.3` => `^1.2.3`
    range = range.replace(re$3[t$3.CARETTRIM], caretTrimReplace);

    // normalize spaces
    range = range.split(/\s+/).join(' ');

    // At this point, the range is completely trimmed and
    // ready to be split into comparators.

    const compRe = loose ? re$3[t$3.COMPARATORLOOSE] : re$3[t$3.COMPARATOR];
    return range
      .split(' ')
      .map(comp => parseComparator(comp, this.options))
      .join(' ')
      .split(/\s+/)
      // in loose mode, throw out any that are not valid comparators
      .filter(this.options.loose ? comp => !!comp.match(compRe) : () => true)
      .map(comp => new comparator(comp, this.options))
  }

  intersects (range, options) {
    if (!(range instanceof Range)) {
      throw new TypeError('a Range is required')
    }

    return this.set.some((thisComparators) => {
      return (
        isSatisfiable(thisComparators, options) &&
        range.set.some((rangeComparators) => {
          return (
            isSatisfiable(rangeComparators, options) &&
            thisComparators.every((thisComparator) => {
              return rangeComparators.every((rangeComparator) => {
                return thisComparator.intersects(rangeComparator, options)
              })
            })
          )
        })
      )
    })
  }

  // if ANY of the sets match ALL of its comparators, then pass
  test (version) {
    if (!version) {
      return false
    }

    if (typeof version === 'string') {
      try {
        version = new semver(version, this.options);
      } catch (er) {
        return false
      }
    }

    for (let i = 0; i < this.set.length; i++) {
      if (testSet(this.set[i], version, this.options)) {
        return true
      }
    }
    return false
  }
}
var range = Range;




const {
  re: re$3,
  t: t$3,
  comparatorTrimReplace,
  tildeTrimReplace,
  caretTrimReplace
} = re_1;

// take a set of comparators and determine whether there
// exists a version which can satisfy it
const isSatisfiable = (comparators, options) => {
  let result = true;
  const remainingComparators = comparators.slice();
  let testComparator = remainingComparators.pop();

  while (result && remainingComparators.length) {
    result = remainingComparators.every((otherComparator) => {
      return testComparator.intersects(otherComparator, options)
    });

    testComparator = remainingComparators.pop();
  }

  return result
};

// comprised of xranges, tildes, stars, and gtlt's at this point.
// already replaced the hyphen ranges
// turn into a set of JUST comparators.
const parseComparator = (comp, options) => {
  debug_1('comp', comp, options);
  comp = replaceCarets(comp, options);
  debug_1('caret', comp);
  comp = replaceTildes(comp, options);
  debug_1('tildes', comp);
  comp = replaceXRanges(comp, options);
  debug_1('xrange', comp);
  comp = replaceStars(comp, options);
  debug_1('stars', comp);
  return comp
};

const isX = id => !id || id.toLowerCase() === 'x' || id === '*';

// ~, ~> --> * (any, kinda silly)
// ~2, ~2.x, ~2.x.x, ~>2, ~>2.x ~>2.x.x --> >=2.0.0 <3.0.0
// ~2.0, ~2.0.x, ~>2.0, ~>2.0.x --> >=2.0.0 <2.1.0
// ~1.2, ~1.2.x, ~>1.2, ~>1.2.x --> >=1.2.0 <1.3.0
// ~1.2.3, ~>1.2.3 --> >=1.2.3 <1.3.0
// ~1.2.0, ~>1.2.0 --> >=1.2.0 <1.3.0
const replaceTildes = (comp, options) =>
  comp.trim().split(/\s+/).map((comp) => {
    return replaceTilde(comp, options)
  }).join(' ');

const replaceTilde = (comp, options) => {
  const r = options.loose ? re$3[t$3.TILDELOOSE] : re$3[t$3.TILDE];
  return comp.replace(r, (_, M, m, p, pr) => {
    debug_1('tilde', comp, _, M, m, p, pr);
    let ret;

    if (isX(M)) {
      ret = '';
    } else if (isX(m)) {
      ret = `>=${M}.0.0 <${+M + 1}.0.0`;
    } else if (isX(p)) {
      // ~1.2 == >=1.2.0 <1.3.0
      ret = `>=${M}.${m}.0 <${M}.${+m + 1}.0`;
    } else if (pr) {
      debug_1('replaceTilde pr', pr);
      ret = `>=${M}.${m}.${p}-${pr
      } <${M}.${+m + 1}.0`;
    } else {
      // ~1.2.3 == >=1.2.3 <1.3.0
      ret = `>=${M}.${m}.${p
      } <${M}.${+m + 1}.0`;
    }

    debug_1('tilde return', ret);
    return ret
  })
};

// ^ --> * (any, kinda silly)
// ^2, ^2.x, ^2.x.x --> >=2.0.0 <3.0.0
// ^2.0, ^2.0.x --> >=2.0.0 <3.0.0
// ^1.2, ^1.2.x --> >=1.2.0 <2.0.0
// ^1.2.3 --> >=1.2.3 <2.0.0
// ^1.2.0 --> >=1.2.0 <2.0.0
const replaceCarets = (comp, options) =>
  comp.trim().split(/\s+/).map((comp) => {
    return replaceCaret(comp, options)
  }).join(' ');

const replaceCaret = (comp, options) => {
  debug_1('caret', comp, options);
  const r = options.loose ? re$3[t$3.CARETLOOSE] : re$3[t$3.CARET];
  return comp.replace(r, (_, M, m, p, pr) => {
    debug_1('caret', comp, _, M, m, p, pr);
    let ret;

    if (isX(M)) {
      ret = '';
    } else if (isX(m)) {
      ret = `>=${M}.0.0 <${+M + 1}.0.0`;
    } else if (isX(p)) {
      if (M === '0') {
        ret = `>=${M}.${m}.0 <${M}.${+m + 1}.0`;
      } else {
        ret = `>=${M}.${m}.0 <${+M + 1}.0.0`;
      }
    } else if (pr) {
      debug_1('replaceCaret pr', pr);
      if (M === '0') {
        if (m === '0') {
          ret = `>=${M}.${m}.${p}-${pr
          } <${M}.${m}.${+p + 1}`;
        } else {
          ret = `>=${M}.${m}.${p}-${pr
          } <${M}.${+m + 1}.0`;
        }
      } else {
        ret = `>=${M}.${m}.${p}-${pr
        } <${+M + 1}.0.0`;
      }
    } else {
      debug_1('no pr');
      if (M === '0') {
        if (m === '0') {
          ret = `>=${M}.${m}.${p
          } <${M}.${m}.${+p + 1}`;
        } else {
          ret = `>=${M}.${m}.${p
          } <${M}.${+m + 1}.0`;
        }
      } else {
        ret = `>=${M}.${m}.${p
        } <${+M + 1}.0.0`;
      }
    }

    debug_1('caret return', ret);
    return ret
  })
};

const replaceXRanges = (comp, options) => {
  debug_1('replaceXRanges', comp, options);
  return comp.split(/\s+/).map((comp) => {
    return replaceXRange(comp, options)
  }).join(' ')
};

const replaceXRange = (comp, options) => {
  comp = comp.trim();
  const r = options.loose ? re$3[t$3.XRANGELOOSE] : re$3[t$3.XRANGE];
  return comp.replace(r, (ret, gtlt, M, m, p, pr) => {
    debug_1('xRange', comp, ret, gtlt, M, m, p, pr);
    const xM = isX(M);
    const xm = xM || isX(m);
    const xp = xm || isX(p);
    const anyX = xp;

    if (gtlt === '=' && anyX) {
      gtlt = '';
    }

    // if we're including prereleases in the match, then we need
    // to fix this to -0, the lowest possible prerelease value
    pr = options.includePrerelease ? '-0' : '';

    if (xM) {
      if (gtlt === '>' || gtlt === '<') {
        // nothing is allowed
        ret = '<0.0.0-0';
      } else {
        // nothing is forbidden
        ret = '*';
      }
    } else if (gtlt && anyX) {
      // we know patch is an x, because we have any x at all.
      // replace X with 0
      if (xm) {
        m = 0;
      }
      p = 0;

      if (gtlt === '>') {
        // >1 => >=2.0.0
        // >1.2 => >=1.3.0
        gtlt = '>=';
        if (xm) {
          M = +M + 1;
          m = 0;
          p = 0;
        } else {
          m = +m + 1;
          p = 0;
        }
      } else if (gtlt === '<=') {
        // <=0.7.x is actually <0.8.0, since any 0.7.x should
        // pass.  Similarly, <=7.x is actually <8.0.0, etc.
        gtlt = '<';
        if (xm) {
          M = +M + 1;
        } else {
          m = +m + 1;
        }
      }

      ret = `${gtlt + M}.${m}.${p}${pr}`;
    } else if (xm) {
      ret = `>=${M}.0.0${pr} <${+M + 1}.0.0${pr}`;
    } else if (xp) {
      ret = `>=${M}.${m}.0${pr
      } <${M}.${+m + 1}.0${pr}`;
    }

    debug_1('xRange return', ret);

    return ret
  })
};

// Because * is AND-ed with everything else in the comparator,
// and '' means "any version", just remove the *s entirely.
const replaceStars = (comp, options) => {
  debug_1('replaceStars', comp, options);
  // Looseness is ignored here.  star is always as loose as it gets!
  return comp.trim().replace(re$3[t$3.STAR], '')
};

// This function is passed to string.replace(re[t.HYPHENRANGE])
// M, m, patch, prerelease, build
// 1.2 - 3.4.5 => >=1.2.0 <=3.4.5
// 1.2.3 - 3.4 => >=1.2.0 <3.5.0 Any 3.4.x will do
// 1.2 - 3.4 => >=1.2.0 <3.5.0
const hyphenReplace = ($0,
  from, fM, fm, fp, fpr, fb,
  to, tM, tm, tp, tpr, tb) => {
  if (isX(fM)) {
    from = '';
  } else if (isX(fm)) {
    from = `>=${fM}.0.0`;
  } else if (isX(fp)) {
    from = `>=${fM}.${fm}.0`;
  } else {
    from = `>=${from}`;
  }

  if (isX(tM)) {
    to = '';
  } else if (isX(tm)) {
    to = `<${+tM + 1}.0.0`;
  } else if (isX(tp)) {
    to = `<${tM}.${+tm + 1}.0`;
  } else if (tpr) {
    to = `<=${tM}.${tm}.${tp}-${tpr}`;
  } else {
    to = `<=${to}`;
  }

  return (`${from} ${to}`).trim()
};

const testSet = (set, version, options) => {
  for (let i = 0; i < set.length; i++) {
    if (!set[i].test(version)) {
      return false
    }
  }

  if (version.prerelease.length && !options.includePrerelease) {
    // Find the set of versions that are allowed to have prereleases
    // For example, ^1.2.3-pr.1 desugars to >=1.2.3-pr.1 <2.0.0
    // That should allow `1.2.3-pr.2` to pass.
    // However, `1.2.4-alpha.notready` should NOT be allowed,
    // even though it's within the range set by the comparators.
    for (let i = 0; i < set.length; i++) {
      debug_1(set[i].semver);
      if (set[i].semver === comparator.ANY) {
        continue
      }

      if (set[i].semver.prerelease.length > 0) {
        const allowed = set[i].semver;
        if (allowed.major === version.major &&
            allowed.minor === version.minor &&
            allowed.patch === version.patch) {
          return true
        }
      }
    }

    // Version has a -pre, but it's not one of the ones we like.
    return false
  }

  return true
};

const ANY = Symbol('SemVer ANY');
// hoisted class for cyclic dependency
class Comparator {
  static get ANY () {
    return ANY
  }
  constructor (comp, options) {
    if (!options || typeof options !== 'object') {
      options = {
        loose: !!options,
        includePrerelease: false
      };
    }

    if (comp instanceof Comparator) {
      if (comp.loose === !!options.loose) {
        return comp
      } else {
        comp = comp.value;
      }
    }

    debug_1('comparator', comp, options);
    this.options = options;
    this.loose = !!options.loose;
    this.parse(comp);

    if (this.semver === ANY) {
      this.value = '';
    } else {
      this.value = this.operator + this.semver.version;
    }

    debug_1('comp', this);
  }

  parse (comp) {
    const r = this.options.loose ? re$4[t$4.COMPARATORLOOSE] : re$4[t$4.COMPARATOR];
    const m = comp.match(r);

    if (!m) {
      throw new TypeError(`Invalid comparator: ${comp}`)
    }

    this.operator = m[1] !== undefined ? m[1] : '';
    if (this.operator === '=') {
      this.operator = '';
    }

    // if it literally is just '>' or '' then allow anything.
    if (!m[2]) {
      this.semver = ANY;
    } else {
      this.semver = new semver(m[2], this.options.loose);
    }
  }

  toString () {
    return this.value
  }

  test (version) {
    debug_1('Comparator.test', version, this.options.loose);

    if (this.semver === ANY || version === ANY) {
      return true
    }

    if (typeof version === 'string') {
      try {
        version = new semver(version, this.options);
      } catch (er) {
        return false
      }
    }

    return cmp_1(version, this.operator, this.semver, this.options)
  }

  intersects (comp, options) {
    if (!(comp instanceof Comparator)) {
      throw new TypeError('a Comparator is required')
    }

    if (!options || typeof options !== 'object') {
      options = {
        loose: !!options,
        includePrerelease: false
      };
    }

    if (this.operator === '') {
      if (this.value === '') {
        return true
      }
      return new range(comp.value, options).test(this.value)
    } else if (comp.operator === '') {
      if (comp.value === '') {
        return true
      }
      return new range(this.value, options).test(comp.semver)
    }

    const sameDirectionIncreasing =
      (this.operator === '>=' || this.operator === '>') &&
      (comp.operator === '>=' || comp.operator === '>');
    const sameDirectionDecreasing =
      (this.operator === '<=' || this.operator === '<') &&
      (comp.operator === '<=' || comp.operator === '<');
    const sameSemVer = this.semver.version === comp.semver.version;
    const differentDirectionsInclusive =
      (this.operator === '>=' || this.operator === '<=') &&
      (comp.operator === '>=' || comp.operator === '<=');
    const oppositeDirectionsLessThan =
      cmp_1(this.semver, '<', comp.semver, options) &&
      (this.operator === '>=' || this.operator === '>') &&
        (comp.operator === '<=' || comp.operator === '<');
    const oppositeDirectionsGreaterThan =
      cmp_1(this.semver, '>', comp.semver, options) &&
      (this.operator === '<=' || this.operator === '<') &&
        (comp.operator === '>=' || comp.operator === '>');

    return (
      sameDirectionIncreasing ||
      sameDirectionDecreasing ||
      (sameSemVer && differentDirectionsInclusive) ||
      oppositeDirectionsLessThan ||
      oppositeDirectionsGreaterThan
    )
  }
}

var comparator = Comparator;

const {re: re$4, t: t$4} = re_1;

const satisfies = (version, range$1, options) => {
  try {
    range$1 = new range(range$1, options);
  } catch (er) {
    return false
  }
  return range$1.test(version)
};
var satisfies_1 = satisfies;

// Mostly just for testing and legacy API reasons
const toComparators = (range$1, options) =>
  new range(range$1, options).set
    .map(comp => comp.map(c => c.value).join(' ').trim().split(' '));

var toComparators_1 = toComparators;

const maxSatisfying = (versions, range$1, options) => {
  let max = null;
  let maxSV = null;
  let rangeObj = null;
  try {
    rangeObj = new range(range$1, options);
  } catch (er) {
    return null
  }
  versions.forEach((v) => {
    if (rangeObj.test(v)) {
      // satisfies(v, range, options)
      if (!max || maxSV.compare(v) === -1) {
        // compare(max, v, true)
        max = v;
        maxSV = new semver(max, options);
      }
    }
  });
  return max
};
var maxSatisfying_1 = maxSatisfying;

const minSatisfying = (versions, range$1, options) => {
  let min = null;
  let minSV = null;
  let rangeObj = null;
  try {
    rangeObj = new range(range$1, options);
  } catch (er) {
    return null
  }
  versions.forEach((v) => {
    if (rangeObj.test(v)) {
      // satisfies(v, range, options)
      if (!min || minSV.compare(v) === 1) {
        // compare(min, v, true)
        min = v;
        minSV = new semver(min, options);
      }
    }
  });
  return min
};
var minSatisfying_1 = minSatisfying;

const minVersion = (range$1, loose) => {
  range$1 = new range(range$1, loose);

  let minver = new semver('0.0.0');
  if (range$1.test(minver)) {
    return minver
  }

  minver = new semver('0.0.0-0');
  if (range$1.test(minver)) {
    return minver
  }

  minver = null;
  for (let i = 0; i < range$1.set.length; ++i) {
    const comparators = range$1.set[i];

    comparators.forEach((comparator) => {
      // Clone to avoid manipulating the comparator's semver object.
      const compver = new semver(comparator.semver.version);
      switch (comparator.operator) {
        case '>':
          if (compver.prerelease.length === 0) {
            compver.patch++;
          } else {
            compver.prerelease.push(0);
          }
          compver.raw = compver.format();
          /* fallthrough */
        case '':
        case '>=':
          if (!minver || gt_1(minver, compver)) {
            minver = compver;
          }
          break
        case '<':
        case '<=':
          /* Ignore maximum versions */
          break
        /* istanbul ignore next */
        default:
          throw new Error(`Unexpected operation: ${comparator.operator}`)
      }
    });
  }

  if (minver && range$1.test(minver)) {
    return minver
  }

  return null
};
var minVersion_1 = minVersion;

const validRange = (range$1, options) => {
  try {
    // Return '*' instead of '' so that truthiness works.
    // This will throw if it's invalid anyway
    return new range(range$1, options).range || '*'
  } catch (er) {
    return null
  }
};
var valid$1 = validRange;

const {ANY: ANY$1} = comparator;







const outside = (version, range$1, hilo, options) => {
  version = new semver(version, options);
  range$1 = new range(range$1, options);

  let gtfn, ltefn, ltfn, comp, ecomp;
  switch (hilo) {
    case '>':
      gtfn = gt_1;
      ltefn = lte_1;
      ltfn = lt_1;
      comp = '>';
      ecomp = '>=';
      break
    case '<':
      gtfn = lt_1;
      ltefn = gte_1;
      ltfn = gt_1;
      comp = '<';
      ecomp = '<=';
      break
    default:
      throw new TypeError('Must provide a hilo val of "<" or ">"')
  }

  // If it satisifes the range it is not outside
  if (satisfies_1(version, range$1, options)) {
    return false
  }

  // From now on, variable terms are as if we're in "gtr" mode.
  // but note that everything is flipped for the "ltr" function.

  for (let i = 0; i < range$1.set.length; ++i) {
    const comparators = range$1.set[i];

    let high = null;
    let low = null;

    comparators.forEach((comparator$1) => {
      if (comparator$1.semver === ANY$1) {
        comparator$1 = new comparator('>=0.0.0');
      }
      high = high || comparator$1;
      low = low || comparator$1;
      if (gtfn(comparator$1.semver, high.semver, options)) {
        high = comparator$1;
      } else if (ltfn(comparator$1.semver, low.semver, options)) {
        low = comparator$1;
      }
    });

    // If the edge version comparator has a operator then our version
    // isn't outside it
    if (high.operator === comp || high.operator === ecomp) {
      return false
    }

    // If the lowest version comparator has an operator and our version
    // is less than it then it isn't higher than the range
    if ((!low.operator || low.operator === comp) &&
        ltefn(version, low.semver)) {
      return false
    } else if (low.operator === ecomp && ltfn(version, low.semver)) {
      return false
    }
  }
  return true
};

var outside_1 = outside;

// Determine if version is greater than all the versions possible in the range.

const gtr = (version, range, options) => outside_1(version, range, '>', options);
var gtr_1 = gtr;

// Determine if version is less than all the versions possible in the range
const ltr = (version, range, options) => outside_1(version, range, '<', options);
var ltr_1 = ltr;

const intersects = (r1, r2, options) => {
  r1 = new range(r1, options);
  r2 = new range(r2, options);
  return r1.intersects(r2)
};
var intersects_1 = intersects;

// just pre-load all the stuff that index.js lazily exports

var semver$1 = {
  re: re_1.re,
  src: re_1.src,
  tokens: re_1.t,
  SEMVER_SPEC_VERSION: constants.SEMVER_SPEC_VERSION,
  SemVer: semver,
  compareIdentifiers: identifiers.compareIdentifiers,
  rcompareIdentifiers: identifiers.rcompareIdentifiers,
  parse: parse_1,
  valid: valid_1,
  clean: clean_1,
  inc: inc_1,
  diff: diff_1,
  major: major_1,
  minor: minor_1,
  patch: patch_1,
  prerelease: prerelease_1,
  compare: compare_1,
  rcompare: rcompare_1,
  compareLoose: compareLoose_1,
  compareBuild: compareBuild_1,
  sort: sort_1,
  rsort: rsort_1,
  gt: gt_1,
  lt: lt_1,
  eq: eq_1,
  neq: neq_1,
  gte: gte_1,
  lte: lte_1,
  cmp: cmp_1,
  coerce: coerce_1,
  Comparator: comparator,
  Range: range,
  satisfies: satisfies_1,
  toComparators: toComparators_1,
  maxSatisfying: maxSatisfying_1,
  minSatisfying: minSatisfying_1,
  minVersion: minVersion_1,
  validRange: valid$1,
  outside: outside_1,
  gtr: gtr_1,
  ltr: ltr_1,
  intersects: intersects_1,
};
var semver_1 = semver$1.re;
var semver_2 = semver$1.src;
var semver_3 = semver$1.tokens;
var semver_4 = semver$1.SEMVER_SPEC_VERSION;
var semver_5 = semver$1.SemVer;
var semver_6 = semver$1.compareIdentifiers;
var semver_7 = semver$1.rcompareIdentifiers;
var semver_8 = semver$1.parse;
var semver_9 = semver$1.valid;
var semver_10 = semver$1.clean;
var semver_11 = semver$1.inc;
var semver_12 = semver$1.diff;
var semver_13 = semver$1.major;
var semver_14 = semver$1.minor;
var semver_15 = semver$1.patch;
var semver_16 = semver$1.prerelease;
var semver_17 = semver$1.compare;
var semver_18 = semver$1.rcompare;
var semver_19 = semver$1.compareLoose;
var semver_20 = semver$1.compareBuild;
var semver_21 = semver$1.sort;
var semver_22 = semver$1.rsort;
var semver_23 = semver$1.gt;
var semver_24 = semver$1.lt;
var semver_25 = semver$1.eq;
var semver_26 = semver$1.neq;
var semver_27 = semver$1.gte;
var semver_28 = semver$1.lte;
var semver_29 = semver$1.cmp;
var semver_30 = semver$1.coerce;
var semver_31 = semver$1.Comparator;
var semver_32 = semver$1.Range;
var semver_33 = semver$1.satisfies;
var semver_34 = semver$1.toComparators;
var semver_35 = semver$1.maxSatisfying;
var semver_36 = semver$1.minSatisfying;
var semver_37 = semver$1.minVersion;
var semver_38 = semver$1.validRange;
var semver_39 = semver$1.outside;
var semver_40 = semver$1.gtr;
var semver_41 = semver$1.ltr;
var semver_42 = semver$1.intersects;

/* eslint-disable security/detect-object-injection */

function getVulnerabilitiesForLibrary(jsLib, vulnsData) {
  const vulnerabilitiesFound = [];
  const jsLibName = jsLib.npm;
  if (!vulnsData || !vulnsData.npm || !vulnsData.npm[jsLibName]) {
    return []
  }

  const jsLibVersion = jsLib.version;

  const jsLibTotalVulns = vulnsData.npm[jsLibName];
  jsLibTotalVulns.forEach(function(vulnInfo) {
    const vulnerableId = vulnInfo.id;
    const vulnerableSeverity = vulnInfo.severity;
    const vulnerableRange = vulnInfo.semver.vulnerable;

    let isVulnerable = false;
    vulnerableRange.forEach(function(semverRangeVulnerable) {
      isVulnerable = semver$1.satisfies(jsLibVersion, semverRangeVulnerable);
    });

    if (isVulnerable) {
      vulnerabilitiesFound.push({
        name: jsLibName,
        severity: vulnerableSeverity,
        version: jsLibVersion,
        url: `https://snyk.io/vuln/${vulnerableId}`
      });
    }
  });

  return vulnerabilitiesFound
}

// d41d8cd98f00b204e9800998ecf8427e_LibraryDetectorTests
async function collectLibraries({ jsLibs, window }) {
  const libraries = [];
  for (const [name, lib] of Object.entries(jsLibs)) {
    try {
      const result = await lib.test(window);
      if (result) {
        libraries.push({
          id: lib.id,
          name: name,
          version: result.version,
          npm: lib.npm
        });
      }
    } catch (e) {}
  }

  return libraries
}

/* eslint-disable no-eval */

async function YWxseW91cmJhc2VhcmViZWxvbmd0b3Vz() {
  const jsLibsDetectorVariableReferrence = eval(
    'd41d8cd98f00b204e9800998ecf8427e_LibraryDetectorTests'
  );

  const libraries = await collectLibraries({
    jsLibs: jsLibsDetectorVariableReferrence,
    window: window
  });

  const vulnerabilitiesFound = [];
  libraries.forEach(function(jsLib) {
    const vulnerabilities = getVulnerabilitiesForLibrary(jsLib, vulnsData);
    vulnerabilitiesFound.push(...vulnerabilities);
  });

  return vulnerabilitiesFound
}
;
return YWxseW91cmJhc2VhcmViZWxvbmd0b3Vz();
